# 상속

### 상속의 개념
: 한 클래스(부모)의 속성과 메서드를 다른 클래스(자식)가 물려받는 것
- 부모 클래스와 자식 클래스 간의 상하 관계가 형성되고, 위쪽에 있는 부모 클래스가 본인의 속성과 메서드를 아래쪽에 있는 자식에게 넘겨주는 것이 상속이다.
- 속성과 메서드를 자식에게 넘겨주는 과정을 상속 과정이라고 한다.

### 상속이 필요한 이유

1. 코드 재사용 
    - 상속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
    - 기존 클래스를 수정하지 않고도 기능을 확장할 수 있음

2. 계층 구조
    - 상속을 통해 클래스들 간의 계층 구조를 형성할 수 있음
    - 부모 클래스와 자식 클래스 간의 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음
3. 상속이 필요한 이유
    - 상속을 통해 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐.
    - 코드의 일관성을 유지하고, 수정이 필요한 범위를 최소화할 수 있음.

### 상속 예시
```python
#부모 클래스
class Animal:
    def eat(self):
        print('먹는 중')

class Dog(Animal) :
    def bark(self) :
        print('멍멍')

my_dog = Dog()  # Dog class로 인스턴스 생성
my_dog.bark()   # 멍멍

# 부모 클래스(Animal) 메서드 사용 가능
my_dog.eat()   # 먹는 중
```

## 클래스 상속

### 상속 없이 구현하는 경우
- 상속이 없이 구현하는 경우 학생/교수 정보를 별도로 표현하기 어려움
- Person class만을 사용하는 경우 학생과 교수가 가지는 각각의 고유 속성을 표현하기 어려움.
- 나이와 이름만으로는 직업 정보를 나타낼 수 없음.
```python
# 상속 없는 경우 - 1개의 공통된 class만 생성
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):
        print(f'반갑습니다. {self.name}입니다.')


s1 = Person('김학생', 23)
s1.talk()  # 반갑습니다. 김학생입니다.

p1 = Person('박교수', 59)
p1.talk()  # 반갑습니다. 박교수입니다.


# 상속 없는 경우 - 2개의 class 생성
class Professor:
    def __init__(self, name, age, department):
        self.name = name
        self.age = age
        self.department = department

    def talk(self):  # 중복
        print(f'반갑습니다. {self.name}입니다.')


class Student:
    def __init__(self, name, age, gpa):
        self.name = name
        self.age = age
        self.gpa = gpa

    def talk(self):  # 중복
        print(f'반갑습니다. {self.name}입니다.')
```

### 상속을 사용한 계층 구조 변경

```python
# 상속을 사용한 계층구조 변경
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):  # 메서드 재사용
        print(f'반갑습니다. {self.name}입니다.')

class Professor(Person):
    def __init__(self, name, age, department):
        self.name = name
        self.age = age
        self.department = department

class Student(Person):
    def __init__(self, name, age, gpa):
        self.name = name
        self.age = age
        self.gpa = gpa


# 부모 Person 클래스의 talk 메서드를 활용
p1 = Professor('김교수', 49, '컴퓨터공학과')  # Professor 인스턴스 생성
p1.talk()

# 부모 Person 클래스의 talk 메서드를 활용
s1 = Student('송학생', 25, 3.5) # Student 인스턴스 생성
s1.talk()
```

## 메서드 오버라이딩

### 메서드 오버라이딩이란?
: 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의하는 것
- 자식 클래스에서 메서드를 다시 정의하면, 부모 클래스의 메서드 대신 자식 클래스의 메서드가 실행된다.
- 오버라이딩은 동일한 이름과 매개변수를 사용하지만, 내부 동작을 원하는 대로 바꿀 수 있게 해줍니다.
- 부모 클래스의 기능을 유지하면서도 일부 동작을 맞춤형으로 바꾸고 싶을 때 유용하다.

### 메서드 오버라이딩 예시
- 자식 클래스가 부모 클래스의 메서드를 덮어써서 새로운 동작을 구현할 수 있음
- Animal class를 상속받은 Dog 클래스에서 eat 메서드를 다시 정의하는 것
```python
class Animal:
    def eat(self):
        print('Animal이 먹는 중')

class Dog(Animal):
    # 오버라이딩 (부모 클래스 Animal의 eat 메서드를 재정의)
    def eat(self) : # 동일한 이름과 매개변수를 사용해야한다고 파이썬은 권장하지만, 다른 매개변수를 추가해도 작동은함. --> 심화내용
        print('Dog가 먹는 중')

my_dog = Dog()
my_dog.eat()
```

## 다중 상속

### 다중 상속이란?
- 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있다.
- 상속받은 모든 클래스의 요소를 활용 가능하다.
- 중복된 속성이나 메서드가 있는 경우 **상속 순서에 의해 결정된다.**

### 다중 상속 예시
```python
# 다중 상속 예시
class Person:
    def __init__(self, name):
        self.name = name

    def greeting(self):
        return f'안녕, {self.name}'


class Mom(Person):
    gene = 'XX'

    def swim(self):
        return '엄마가 수영'


class Dad(Person):
    gene = 'XY'

    def walk(self):
        return '아빠가 걷기'


class FirstChild(Dad, Mom):
    def swim(self):
        return '첫째가 수영'

    def cry(self):
        return '첫째가 응애'


baby1 = FirstChild('아가')
print(baby1.cry())  # 첫째가 응애
print(baby1.swim())  # 첫째가 수영
print(baby1.walk())  # 아빠가 걷기
print(baby1.gene)  # XY (Dad, Mom)으로 매개변수를 작성했기 때문!
```

### 다이아몬드 문제 (The diamond problem)
- 두 클래스 B와 C가 A에서 상속되고 클래스 D가 B와 C 모두에서 상속될 때 발생하는 모호함
- B와 C가 재정의한 메서드 A에 있고 D가 이를 재정의하지 않은 경우라면   
-> D는 B의 메서드 중 어떤 버전을 상속하는가?   
-> 아니면 C의 메서드 버전을 상속하는가?

### 파이썬에서의 해결책
- MRO(Method Resolution Order) 알고리즘을 사용하여 클래스 목록을 생성
- 부모 클래스로부터 상속된 속성을 정해진 내부 알고리즙에 따라 검색
- 이 순서는 기본적으로 왼쪽에서 오른쪽으로 진행되며, 계층 구조에서 중복되는 클래스는 한 번만 확인
- 그래서, 속성이 D에서 발견되지 않으면, B에서 찾고, 거기에서도 발견되지 않으면, C에서 찾고, 이런식으로 진행됨
``` python
class D(B, C) :
    pass
```

### 메서드 결정 순서(MRO)
: 파이썬이 메서드를 찾는 순서에 대한 규칙. 메서드 결정 순서.

- MRO는 다중 상속에서 어떤 부모 클래스의 메서드를 먼저 사용할지 순서를 정의한다.
- 파이썬은 미리 정해진 MRO를 통해 다중 상속 환경에서도 예측 가능한 방식으로 메서드 탐색이 이루어질 수 있도록 한다.

## super() 메서드

### super() 란?
: 메서드 해석 순서에 따라, 현재 클래스의 부모(상위) 클래스의 메서드나 속성에 접근할 수 있게 해주는 내장 함수
- super()를 사용하면 직접 부모 클래스 이름을 적지 않아도 MRO에 따라 자동으로 올바른 메서드를 찾아 실행할 수 있다.
- 다중 상속에서 super()를 호출하면 상속 순서에 맞춰 여러 부모 클래스의 메서드를 순차적으로 실행할 수 있다.
- 생성자나 오버라이딩된 메서드에서 super()를 호출하면 부모 클래스의 초기화나 로직을 그대로 활용 가능하다.

### super() 특징
- 단순히 "부모 클래스의 메서드를 호출"하기 위한 용도 뿐만 아니라, 다중 상속이 있을 때도 올바른 순서에 따라 상위 클래스의 메서드를 찾아 실행하기 위해 super()를 사용

### super()의 2가지 사용 사례
1. 단일 상속 구조
2. 다중 상속 구조

### super() 사용 예시 (단일 상속)
- 명시적으로 부모 클래스 이름을 적지 않아도 부모 메서드를 안전하게 호출할 수 있음

``` python
# super를 사용하지 않았을 때
class Person:
    def __init__(self, name, age, number, email):
        self.name = name
        self.age = age
        self.number = number
        self.email = email


class Student(Person):
    def __init__(self, name, age, number, email, student_id):
        self.name = name
        self.age = age
        self.number = number
        self.email = email
        self.student_id = student_id


# super를 사용했을 때
class Person:
    def __init__(self, name, age, number, email):
        self.name = name
        self.age = age
        self.number = number
        self.email = email


class Student(Person):
    def __init__(self, name, age, number, email, student_id):
        # super()를 통해 Person의 __init__ 메서드 호출
        super().__init__(name, age, number, email)
        self.student_id = student_id
```
> - studennt의 생성자에서 `super().__init__()`를 호출하면, Person의 `__init()` 메서드가 호출되어 name, age, number, email 속성을 초기화한 뒤 Student 고유의 stuednt_id 속성을 추가
> - 이때 Person 클래스를 직접 명시하지 않고 super()를 사용하므로, 나중에 클래스 이름이 바뀌거나 상속 구조가 변경되어도 super() 호출 부분을 그대로 사용할 수 있어 유지보수성 향상.

### 단일 상속 구조에서의 super 함수
- "부모 클래스의 생성자(또는 매서드)를 호출하기 위해 사용"
- 명시적으로 이름을 지정하지 않고 부모 클래스를 참조할 수 있으므로, 코드를 더 유지 관리하기 쉽게 만들 수 있음
- 클래스 이름이 변경되거나 부모 클래스가 교체되어도 super()를 사용하면 코드 수정이 더 적게 필요

> TIP   
> - 단일 상속에서는 super()를 사용해 부모 클래스를 직접 지정하지 않고 메서드를 호출한다.
> - 이렇게 하면 나중에 부모 클래스 이름이 바뀌거나 계층이 수정돼도 코드 유지 관리가 훨씬 수월해진다.


### super() 사용 예시 (다중 상속)


``` python
# 다중 상속
class ParentA:
    def __init__(self):
        # super().__init__()
        self.value_a = 'ParentA'

    def show_value(self):
        print(f'Value from ParentA: {self.value_a}')


class ParentB:
    def __init__(self):
        self.value_b = 'ParentB'

    def show_value(self):
        print(f'Value from ParentB: {self.value_b}')


class Child(ParentA, ParentB):
    def __init__(self):
        super().__init__()  # ParentA 클래스의 __init__ 메서드 호출
        self.value_c = 'Child'

    def show_value(self):
        super().show_value()  # ParentA 클래스의 show_value 메서드 호출
        print(f'Value from Child: {self.value_c}')


child = Child()
child.show_value()
"""
Value from ParentA: ParentA
Value from Child: Child
"""

print(child.value_c)  # Child
print(child.value_a)  # ParentA
print(
    child.value_b
)  # AttributeError: 'Child' object has no attribute 'value_b'
```

### 다중 상속 구조에서의 super 함수
- MRO(메서드 해석 순서)에 따라 각 클래스의 메서드를 찾아가기 때문에, 단순히 직계 부모만이 아니라 다중 상속 관계에서도 적절한 상위 클래스의 메서드를 안전하게 호출할 수 있음
- 이를 통해 복잡한 상속 구조에서도 코드를 유연하고 깔끔하게 유지할 수 있음

### super() 정리
- super()를 사용할 때는 MRO를 잘 이해하고 있어야 함.
- ClassName.__mro_ 또는 ClassName.mro()를 확인해 MRO 순서를 파악한 뒤 적절히 활용하는 연습을 하면, 보다 복잡한 상속 구조에서도 코드를 잘 관리할 수 있음

### MRO가 필요한 이유

- 부모 클래스들이 여러 번 액세스 되지 않도록, 각 클래스에서 지정된 왼쪽에서 오르쪽으로 가는 순서를 보존하고, 각 부모를 오직 한 번만 호출하고, 부모들의 우선순위에 영향을 주지 않으면서 서브 클래스를 만드는 단조적인 구조 형성

# 에러와 예외

## 디버깅

### 버그
: 소프트웨어에서 발생하는 오류 또는 결함 프로그램의 예상된 동작과 실제 동작 사이의 불일치

### 디버깅
: 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정   
: 프로그램의 오작동 원인을 식별하여 수정하는 작업

- 디버깅은 코드 실행 과정에서 변수 값이나 흐름을 점검하며 문제의 정확한 위치와 원인을 찾아내는 과정이다.
- 효과적인 디버깅을 위해 단계별로 코드를 실행하거나 로그를 출력해 프로그램 상태를 확인한다.

### 디버깅 방법

1. print 함수 활용
    - 특정 함수 결과, 반복/조건 결과 등 나눠서 생각, 코드를 bisection으로 나눠서 생각
2. 개발 환경 (text editor, IDE) 등에서 제공하는 기능 활용
    - breakpoint, 변수 조회 등
3. Python tutor 활용 (단순 파이썬 코드인 경우)
4. 뇌 컴파일, 눈 디버깅 등

## 에러
: 프로그램 실행 중에 발생하는 예외 상황

- 프로그램을 실행할 때 예상치 못한 문제가 발생하면 오류가 생긴다.
- 예를 들어, 존재하지 않는 파일을 읽으려 하거나 0으로 나누면 오류가 발생한다. 이러한 상황을 처리하지 않으면 프로그램이 중단된다.

### 파이썬의 에러 유형

|문법 에러|예외|
|--------|----|
|Syntax Error|Exception|
|프로그램의 구문이 올바르지 않은 경우 발생|프로그램 실행 중에 감지되는 에러|

### 문법 에러 예시
1. Invalid syntax (문법 오류)
2. assign to literal (잘못된 할당)
3. Unterminated string literal
    - 보통 문자열이나 문장을 제대로 닫지 않은 상태에서 줄 끝에 다다랐을 때 발생

## 예외
: 프로그램 중에 감지되는 에러
- 예외는 프로그램이 잘못된 동작을 시도할 때 자동으로 감지된다.
- 예를 들어, 리스트에 없는 값을 꺼내려 하면 예외가 발생한다.
- 이런 상황을 처리하지 않으면 프로그램은 즉시 종료됨.

### 내장 예외
: 예외 상황을 나타내는 예외 클래스들
- 내장 예외는 파이썬에서 이미 정의되어 있으며, 특정 예외 상황에 대한 처리를 위해 사용한다.

1. ZeroDivisionError : 나누기 또는 모듈로 연산의 두 번째 인자가 0일 때 발생
2. NameError : 지역 또는 전역 이름을 찾을 수 없을 때 발생
3. TypeError : 타입 불일치, 인자 누락, 인자 초과, 인자 타입 불일치
4. ValueError : 연산이나 함수에 문제가 없지만 부적절한 값을 가진 인자를 받았고, 상황이 IndexError처럼 더 구체적인 예외로 설명되지 않는 경우 발생
5. IndexError : 시퀀스 인덱스가 범위를 벗어남.
6. KeyError : 딕셔너리에 해당 키가 존재하지 않는 경우
7. ImportError : import하려는 이름을 찾을 수 없을 때
8. ModuleNotFoundError : 모듈을 찾을 수 없을 때
9. KeyboardInterrupt : 사용자가 Control-C 또는 Delete를 누를 때 발생 (무한루프 시 강제 종료)
10. IndentationError : 잘못된 들여쓰기와 관련된 문법 오류

## 예외 처리
: 예외가 발생했을 때 프로그램이 비정상적으로 종료되지 않고, 적절하게 처리할 수 있도록 하는 방법
- 예외 처리를 통해 오류가 발생해도 프로그램의 흐름을 안전하게 이어갈 수 있다.
- Python에서는 try, except 구문을 사용해 특정 예외를 잡아내고 원하는 동작을 수행할 수 있다.

### 예외처리 사용 구문
1. try
    - 예외가 발생할 수 있는 코드 작성
2. except
    - 예외가 발생했을 때 실행할 코드 작성
3. else
    - 예외가 발생하지 않았을 때 실행할 코드 작성
4. finally
    - 예외 발생 여부와 상관없이 항상 실행할 코드 작성
```python
try:
    x = int(input('숫자를 입력하세요: '))
    y = 10 / x
except ZeroDivisionError :
    print('0으로 나눌 수 없습니다.')
except ValueError :
    print('유효한 숫자가 아닙니다.')

else :
    print(f'결과: {y}')

finally :
    print('프로그램이 종료되었습니다.')
```

## try & except

### try & except 구조
```python
try :
  # 예외가 발생할 수 있는 코드
except 예외 :
  # 예외 처리 코드
```

- try 블록 안에는 예외가 발생할 수 있는 코드를 작성
- except 블록 안에는 예외가 발생했을 때 처리할 코드 작성한다.
- 예외가 발생하면 프로그램 흐름은 try블록을 빠져나와 해당 예외에 대응하는 except 블록으로 이동한다.

## 복수 예외 처리

### 복수 예외 처리 연습
```python
# 복수 예외처리
try:
    num = int(input('100을 나눌 값을 입력하시오 : '))
    print(100 / num)
except (ValueError, ZeroDivisionError):
    print('제대로 입력해주세요.')


try:
    num = int(input('100을 나눌 값을 입력하시오 : '))
    print(100 / num)
except ValueError:
    print('숫자를 넣어주세요.')
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')
except:
    print('에러가 발생했습니다.')
```

## else & finally

- else 블록은 예외가 발생하지 않았을 때 추가 작업을 진행
- finally 블록은 예외 발생 여부와 상관없이 항상 실행할 코드를 작성

# 참고

## 예외 처리 주의사항

### 내장 예외의 상속 계층구조 주의
- 예외를 작성하면 코드는 2번째 except 절에 이후로 도달하지 못함.
- 범용적인 예외처리인 Exception을 먼저 적어버리면, 모든 예외를 먼저 가로채기 때문에, 아래에 ZeroDivisionError 전용 처리 등을 적어 놓아도 실행되지 못함.
- 항상 범용적인 예외처리 Exception은 마지막에 두어야 한다.
- 내장 예외 클래스는 상속 계층구조를 가지기 때문에 except 절로 분기 시 **반드시 하위 클래스를 먼저 확인할 수 있도록 작성**해야 함.
- 가장 구체적인 예외부터 처리하고, 마지막에 범용 예외를 처리하도록 순서 배치

## 예외 객체 다루기

### as 키워드
- 예외객체 : 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
- except 블록에서 예외 객체를 받아 상세한 예외 정보를 활용 가능

```python
my_list = []

try:
    number = my_list[1]
except IndexError as error:
    print(f'{error}가 발생했습니다.')
    # list index out of range가 발생했습니다.
```
- 빈리스트에서 잘못된 인덱스를 참조할 때 IndexError 예외가 발생하는 예시.
- error 변수에 담긴 예외 메시지를 출력하면 구체적인 오류 내용을 쉽게 확인할 수 있다.

### try-except와 if-else
- try-except와 if-else를 함께 사용할 수 있음
```python
try:
  x = int(input('숫자를 입력하세요: '))
  if x < 0 :
    print('음수를 허용되지 않습니다.')
  else :
    print('입력한 숫자:', x)
except ValueError :
  print('오류발생')
```

## EAFP & LBYL

|EAFP|LBYL|
|----|----|
"Easier to Ask for Forgiveness than Permission"|"Look Befor You Leap"|
|예외처리를 중심으로 코드를 작성하는 접근 방식|값 검사를 중심으로 코드를 작성하는 접근 방식|
|try-except|if-else|

### 접근 방식 비교

```python
my_dict = {
    'key': 'value',
}

# EAFP (Easier to Ask for Forgiveness than Permission)
try:
    result = my_dict['key']
    print(result)
except KeyError:
    print('Key가 존재하지 않습니다.')


# LBYL (Look Before You Leap)
if 'key' in my_dict:
    result = my_dict['key']
    print(result)
else:
    print('Key가 존재하지 않습니다.')
```

|EAFP|LBYL|
|----|----|
|"일단 실행하고 예외를 처리"|"실행하기 전에 조건을 검사"|
|코드를 실행하고 예외가 발생하면 예외처리를 수행|코드 실행 전에 조건문 등을 사용하여 에외 상황을 미리 검사하고, 예외 상황을 피하는 방식|
|코드에서 예외가 발생할 수 있는 부분을 미리 예측하여 대비하는 것이 아니라, 예외가 발생한 후에 예외를 처리|코드가 좀 더 예측 가능한 동작을 하지만, 코드가 더 길고 복잡해질 수 있음|
|예외 상황을 예측하기 어려운 경우에 유용|예외 상황을 미리 방지하고 싶을 때 유용|

## 클래스의 의미와 활용

### 클래스 사용의 효능
#### 왜 클래스를 배웠을까?
- 지금까지 우리는 변수와 함수만으로도 간단한 프로그램을 만들 수 있었다.
- 그러나 프로그램 규모가 커지면 서로 관련 있는 정보와 기능을 따로따로 관리하기가 점점 어려워진다.
- 클래스를 사용하면 관련된 데이터와 기능을 '한 덩어리'로 묶어 구조를 명확히 할 수 있다.
- 이로써 작성한 코드가 훨씬 깔끔해지고, 나중에 수정하거나 기능을 추가할 때 더 쉽고 안전해진다.
