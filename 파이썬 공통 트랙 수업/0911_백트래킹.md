# 백트래킹

## 백트래킹 응용

### N-Queen 문제

- `n x n` 서양 장기판에서 배치한 Queen들이 서로 위협하지 않도록 n개의 Queen을 배치하는 문제
    - 어떤 두 Queen도 서로를 위협하지 않아야 한다.
    - 즉, 같은 행(row), 열(column), 대각선(diagonal) 위에 놓일 수 없음
    - Queen을 배치한 n개의 위치는?

#### ♟️핵심 아이디어
- 체스에서 퀸은 상하좌우 + 대각선 방향으로 이동 가능
- 따라서 퀸들이 배치될 때 다음 제약 조건을 만족해야 함:
    - 같은 행에 두 퀸 존재 ❌
    - 같은 열에 두 퀸 존재 ❌
    - 같은 대각선(↘, ↙)에 두 퀸 존재 ❌

>N-Queen 문제는 조합 최적화 문제이자 대표적 백트래킹 예제   
>문제 해결 과정에서 가지치기(Pruning) 기법이 중요   


### 백트래킹 개념
- 여러 가지 선택지(옵션)들이 존재하는 상황에서 한 가지를 선택함
- 선택이 이루어지면 새로운 선택지들의 집합이 생성됨
- 이런 선택을 반복하면서 최종 상태에 도달함
  - 올바른 선택을 계속하면 목표 상태(goal state)에 도달하게 된다.

### 당첨 리프 노드 찾기 
- 루트에서 갈 수 있는 노드를 선택함
- 꽝 노드(실패 지점)에 도달하면 → 최근의 선택으로 **되돌아가서** 다른 경로 탐색
- 선택할 수 있는 경로가 더 이상 없으면 → 다시 이전 단계로 **백트래킹**
- 루트까지 돌아갔는데도 새로운 선택지가 없다면 → **답이 없음**

```
      Root
     /    \
    A      B
   / \    / \
  C   D  E   F   # C, D, F → 꽝 노드(실패), E → 당첨 노드(성공)
```

- 🧩 탐색 과정 (DFS + 백트래킹)
  - 1) Root → A → C : ❌ (꽝 → 되돌아감)
  - 2) Root → A → D : ❌ (꽝 → 되돌아감)
  - 3) Root → B → E : ✅ (당첨 → 탐색 성공!)


### 백트래킹과 깊이 우선 탐색과의 차이

#### 깊이 우선 탐색(DFS)

모든 경로를 끝까지 탐색하는 방식

불필요한 경로까지 모두 탐색 → 비효율적

#### 백트래킹(Backtracking)

어떤 경로가 더 이상 해답으로 이어질 수 없다고 판단되면, 그 경로는 더 이상 탐색하지 않고 조기 차단

이 과정을 **Pruning(가지치기)** 라 부름

경우의 수가 많을 경우 (예: N! 가지 경우의 수)

- 복잡도 비교
  - 단순 DFS → 처리 불가능 (시간 폭발)
  - 백트래킹 → 경우의 수 줄어들지만 최악의 경우에는 여전히 지수 함수 시간(Exponential Time) 소요
  - 따라서 완전히 효율적이라고 할 수는 없음


### 백트래킹 개념

루트 노드에서 리프(leaf) 노드까지의 경로는 잠재적 해답 후보(candidate solution)가 됨   
깊이 우선 탐색(DFS)을 사용하면 모든 후보를 전부 탐색 가능   
하지만 해답이 될 가능성이 전혀 없는 불필요한 경로까지 모두 탐색 → 비효율적

따라서 백트래킹에서는 ***불필요한 후보를 조기에 차단***      
👉 모든 후보를 검사하지 않는다!

### 백트래킹 기법

1. **유망성(promising) 검사**

    - 어떤 노드가 해답 가능성이 있는지 확인
    - 유망하지 않다고 판단되면, 그 노드의 부모로 되돌아가(backtracking) 다른 경로 탐색

2. **유망/비유망 판정**

    - 방문한 노드가 해답이 될 수 없음 → 유망하지 않음
    - 해답이 될 가능성 있음 → 유망함

3. **가지치기(pruning)**

    - 유망하지 않은 노드가 포함된 경로는 더 이상 탐색하지 않고 버림
    - 탐색 공간을 대폭 줄여 효율적 탐색 가능

### 백트래킹을 이용한 알고리즘 절차

1) 상태 공간 트리의 깊이 우선 검색을 실시한다.
2) 각 노드가 유망한지를 점검한다.
3) 만일 그 노드가 유망하지 않다면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.

### 상태 공간 트리 (State Space Tree)

문제의 가능한 해답 후보들을 **트리 구조로 표현**한 것

각 레벨(level) - 문제를 해결하기 위한 단계 (예: 체스판의 행)

각 노드(node) - 특정 단계에서의 선택 (예: 특정 열에 퀸을 둔 위치)

리프 노드 - 하나의 완성된 해답 후보 (candidate solution)

### 상태 공간 트리 예시 (N-Queens)

- Root 노드 : 아무것도 선택하지 않은 초기 상태

- 자식 노드 : 한 행(row)에 퀸을 배치한 경우의 수

- 깊이 탐색 : 해를 찾기 위해 모든 가능한 배치를 단계적으로 확장

- Pruning 적용 : 공격 관계(같은 열/대각선)가 발생하면 해당 분기(branch)는 탐색 중단

---

# 트리

## 트리 개요

### 문제 제시 : 계산기

문제: 수식 `2 + 3 * 4`를 트리 형태로 표현하고, 트리를 순회하며 계산하는 것

#### 수식 트리 표현

```
    +
   / \
  2   *
     / \
    3   4
```

- 🔎 계산 과정 (순회)

1. `*` 노드 계산 → 3 * 4 = 12
2. `+` 노드 계산 → 2 + 12 = 14

👉 최종 결과: 14

### 트리(Tree) 정의

- 트리는 **싸이클이 없는 <u>무향 연결</u> 그래프**

  - 두 노드 사이에는 **<u>유일한 경로</u>** 가 존재
  - 각 노드는 최대 하나의 부모 노드를 가질 수 있음
  - 각 노드는 0개 이상의 자식 노드를 가질 수 있음

- **비선형 구조**
  - 원소 간 1:n 관계를 가짐
  - 계층적(hierarchical) 자료 구조

### 트리의 구성 요소

#### 노드(Node, Vertex)

트리의 원소 (예: A, B, C, …)

#### 간선(Edge)
부모와 자식을 연결하는 선

#### 루트 노드(Root Node)
트리의 시작 노드 (예: A)

#### 리프 노드(Leaf Node)
자식 노드가 없는 노드 (예: E, G, K, H, I, J)

### 트리 용어
| 용어                          | 정의                        | 예시 (트리 T 기준)                    |
| --------------------------- | ------------------------- | ------------------------------- |
| **노드 (Node, Vertex)**       | 트리의 원소, 정점이라고도 함          | A, B, C, D, E, F, G, H, I, J, K |
| **간선 (Edge)**               | 부모와 자식 노드를 연결하는 선         | A–B, B–F, D–H 등                 |
| **루트 노드 (Root Node)**       | 트리의 시작 노드                 | A                               |
| **리프 노드 (Leaf Node)**       | 자식 노드가 없는 노드              | E, K, G, H, I, J                |
| **형제 노드 (Sibling Node)**    | 같은 부모를 가진 자식 노드           | B, C, D                         |
| **조상 노드 (Ancestor Node)**   | 루트에서 해당 노드까지 경로에 있는 모든 노드 | K의 조상 → F, B, A                 |
| **자손 노드 (Descendant Node)** | 해당 노드의 서브트리에 포함된 하위 노드    | B의 자손 → E, F, K                 |
| **서브트리 (Subtree)**          | 어떤 노드를 루트로 하는 작은 트리       | B를 루트로 하는 서브트리: (B, E, F, K)    |
| **노드의 차수 (Degree of Node)** | 해당 노드에 연결된 자식 노드의 수       | B의 차수 = 2, C의 차수 = 1            |
| **트리의 차수 (Degree of Tree)** | 트리에서 가장 큰 노드의 차수 값        | 트리 T의 차수 = 3                    |
| **노드의 높이 (Level, Depth)**   | 루트에서 해당 노드까지의 간선 수        | B의 높이 = 1, F의 높이 = 2            |
| **트리의 높이 (Height of Tree)** | 트리 내 모든 노드 높이 중 최댓값       | 트리 T의 높이 = 3                    |

