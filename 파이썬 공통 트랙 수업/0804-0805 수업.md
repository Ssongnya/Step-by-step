# List

## 알고리즘 기초

### 알고리즘이란?

문제를 해결하기 위한 유한한 _절차나 방법_
- 컴퓨터가 일을 수행하기 위한 단계적인 방법을 뜻한다.

예) 1부터 100까지의 합 구하기

- 방법 1: `1 + 2 + 3 + … + 100` → 반복문으로 계산
- 방법 2: `(1 + 100) * 50 = 5050` → 공식 이용

같은 문제여도 접근 방법에 따라 효율이 확 달라진다.

### 알고리즘 표현 방법

1. **슈도코드**  
: 실제 프로그래밍 언어는 아니지만, 로직을 코드처럼 흉내 내서 표현. 실행은 안 되지만 설계할 때 유용함.
    
    ```
    CalcSum(n)
        sum ← 0
        for i from 1 to 100:
            sum ← sum + i
        return sum
    ```
    
2. **순서도**   
: 프로그램 흐름을 도식화한 그림. 복잡한 알고리즘을 한눈에 보기 좋음.

### 알고리즘 성능 분석

좋은 알고리즘의 기준

- 정확성: 제대로 동작하는가?
- 작업량: 연산 횟수가 적은가?
- 메모리 사용량: 메모리를 덜 쓰는가?
- 단순성: 이해하기 쉽고 단순한가?
- 최적성: 더 개선할 여지가 없는가?

결국 성능 비교는 **연산 횟수**를 많이 본다.

### 시간 복잡도 (Big-O 표기법)

- 알고리즘이 입력 크기 `n`에 따라 걸리는 시간을 수학적으로 표현.
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 `n`에 대한 항만을 표시
- 계수는 생략하여 표시

### 코드 비교

```python
# 방법 1: 반복문으로 합 구하기 (O(n))
def sum_loop(n):
    total = 0                   # 1번
    for i in range(1, n + 1):   # n번
        total += i              # n번
    return total    

# 방법 2: 공식으로 합 구하기 (O(1))
def sum_formula(n):
    return n * (n + 1) // 2     # 3번

print(sum_loop(100))     # 출력: 5050
print(sum_formula(100))  # 출력: 5050
```

실행 결과는 같지만, 반복문은 100번 돌고 공식은 딱 한 번(복잡도가 1) 계산한다. → 공식이 훨씬 효율적임.

---

## 배열

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

### 배열의 예시

📌 6개의 변수를 사용해야 하는 경우
- 이를 배열로 바꾸어 사용하는 예시

1. 기존 방식 (변수 개별 선언)
``` python
num0 = 0
num1 = 1
num2 = 2
num3 = 3
num4 = 4
num5 = 5
```
2. 배열을 활용한 방식
```python
복사
편집
num = [0, 1, 2, 3, 4, 5]
```

✅ 장점:

- 변수 선언이 간결해짐
- 반복문과 함께 사용 가능 → 유지보수 용이

### 배열의 필요성

- 프로그램 내에서 여러 개의 변수가 필요할 때
    - 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있다.
- 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언
- 단순히 다수의 변수 선언을 의미하는 것이 아님
    - 다수의 변수로는 하기 힘든 작업을 배열을 활용하여 쉽게할 수 있다.

### 1차원 배열

배열을 선언할 때는 프로그램에서 사용할 배열 이름이 필요하다.

#### 1차원 배열 선언의 예시
```python
arr = list()
arr = []
arr = [0] * 10
arr = [1, 2, 3]
```

#### 1차원 배열 접근의 예시
```python
arr[0] = 10     # 배열 arr의 0번 원소에 10을 저장하라
arr[idx] = 20   # 배열 arr의 idx번 원소에 20을 저장하라
```

### 입력 받은 정수를 1차원 배열에 저장하는 방법

1️⃣ 개념 예시
- 첫 줄에 양수의 개수 N이 주어진다.
- 조건: 5 ≤ N ≤ 1000
- 다음 줄에는 빈칸으로 구분된 N개의 양수가 주어진다.
- 조건: 1 ≤ Ai ≤ 1,000,000

입력받은 값을 1차원 배열(리스트)에 저장하여 활용할 수 있다

2️⃣ 예제

#### 입력
```
6
2 7 5 3 1 4
```
#### 배열 구조
| 인덱스 | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | - | - | - | - | - | - |
| 값   | 2 | 7 | 5 | 3 | 1 | 4 |


📌 N = 6

3️⃣ 파이썬 코드 예시
```python
# N값 입력받기
N = int(input())  # 정수 입력 → 예: 6

# N개의 정수를 공백으로 구분하여 입력받고 리스트로 저장
arr = list(map(int, input().split()))  # 예: 2 7 5 3 1 4

print(arr)  # 출력: [2, 7, 5, 3, 1, 4]
```

4️⃣ 핵심 포인트
- map(int, input().split()) : 공백으로 구분된 문자열을 정수로 변환
- list(...) : 변환된 값을 리스트 형태로 저장
- 인덱스를 통해 개별 요소에 접근 가능 (arr[0], arr[1], …)

✅ 예시

```python
print(arr[0])  # 2
print(arr[3])  # 3
```

### 배열 원소의 합 s 계산하기

1️⃣ 개념 정리   

배열에 저장된 원소들을 모두 더하여 합을 구할 수 있다.   
반복문을 이용해 각 요소를 순회하면서 합계를 누적하는 방식으로 계산한다.

2️⃣ 예제
#### 배열 데이터
| 인덱스 | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | - | - | - | - | - | - |
| 값   | 2 | 7 | 5 | 3 | 1 | 4 |

#### 합 계산 과정
| 단계 | 누적 합(`s`) |
| -- | --------- |
| 시작 | 0         |
| +2 | 2         |
| +7 | 9         |
| +5 | 14        |
| +3 | 17        |
| +1 | 18        |
| +4 | 22        |

3️⃣ 파이썬 코드 예시
```python
# 합계를 저장할 변수 초기화
s = 0

# 방법 1: 인덱스를 이용한 반복문
for i in range(N):
    s += arr[i]

# 방법 2: 직접 배열 요소를 순회
# for x in arr:
#     s += x

print(s)  # 출력: 22
```

4️⃣ 핵심 포인트

- `for i in range(N)` → 인덱스 기반 접근 가능
- `for x in arr` → 배열 요소를 직접 순회 가능
- 두 방법 모두 결과는 동일함
- `sum(arr)`를 사용하면 파이썬 내장 함수로 더 간단히 합을 구할 수도 있음

### 배열 원소 중 최댓값 max_v 찾기

1️⃣ 개념 정리   

배열에 있는 원소들 중 가장 큰 값을 찾는 알고리즘이다.   
첫 번째 원소를 기준으로 최댓값을 가정하고, 나머지 원소와 비교하며 갱신한다.

2️⃣ 예제

#### 배열 데이터
| 인덱스 | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | - | - | - | - | - | - |
| 값   | 2 | 7 | 5 | 3 | 1 | 4 |

#### 최댓값 계산 과정
| 단계 | 비교 값 | 현재 최댓값(`max_v`) |
| -- | ---- | --------------- |
| 시작 | 2    | 2               |
| 비교 | 7    | 7               |
| 비교 | 5    | 7               |
| 비교 | 3    | 7               |
| 비교 | 1    | 7               |
| 비교 | 4    | 7               |

➡️ 최종 최댓값 : 7

3️⃣ 파이썬 코드 예시
```python
# 첫 원소를 최댓값으로 가정
max_v = arr[0]

# 인덱스 1부터 N-1까지 비교
for i in range(1, N):
    if max_v < arr[i]:         # 현재 값이 더 크면
        max_v = arr[i]         # max_v 갱신

print(max_v)  # 출력: 7
```   
   
4️⃣ 핵심 포인트
- 초기값은 arr[0]으로 설정해야 한다.
- 반복문은 인덱스 1부터 시작 (이미 0번은 가정했기 때문)
- max() 함수를 사용하면 더 간단하게 구현 가능하다.

### 배열 원소 중 최댓값의 인덱스 max_idx 찾기

1️⃣ 개념 정리     

배열에서 최댓값이 위치한 인덱스를 찾는 알고리즘이다.   
첫 번째 원소의 인덱스를 기준으로 가정하고, 나머지 원소와 비교하여 더 큰 값을 찾으면 인덱스를 갱신한다.   
**최댓값이 여러 개인 경우, <u>가장 왼쪽(첫 번째로 등장한) 인덱스</u>를 선택한다.**

2️⃣ 예제

#### 배열 데이터
| 인덱스 | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | - | - | - | - | - | - |
| 값   | 2 | 7 | 5 | 3 | 1 | 4 |

#### 최댓값 계산 과정
| 단계 | 비교 값 | 현재 최댓값 인덱스(`max_idx`) |
| -- | ---- | --------------------- |
| 시작 | 2    | 0                     |
| 비교 | 7    | 1                     |
| 비교 | 5    | 1                     |
| 비교 | 3    | 1                     |
| 비교 | 1    | 1                     |
| 비교 | 4    | 1                     |


➡️ 최종 최댓값 인덱스: 1

3️⃣ 파이썬 코드 예시
```python
# 첫 원소의 인덱스를 최댓값으로 가정
max_idx = 0

# 인덱스 1부터 N-1까지 비교
for i in range(1, N):
    if arr[max_idx] < arr[i]:  # 더 큰 값을 만나면
        max_idx = i            # max_idx 갱신

print(max_idx)  # 출력: 1
```   
   
4️⃣ 핵심 포인트
- 초기값은 `0`으로 설정해야 한다.
- 값이 아닌 인덱스를 갱신하는 방식
- `arr.index(max(arr))`를 사용하면 파이썬 내장 기능으로 더 간단히 가능하다.

### 배열에서 값 찾기 (없으면 idx : -1)

1️⃣ 개념 정리     

배열에서 찾는 값 `V`를 순차적으로 탐색한다.   
값을 찾으면 해당 **인덱스**를 저장하고 탐색을 종료한다.
값을 찾지 못하면 `-1`을 결과로 저장한다.

2️⃣ 예제

#### 입력
```python
N = 6   # 배열 크기
V = 5   # 찾는 값
arr = [2, 7, 5, 3, 1, 7]
```

#### 출력 과정
| 인덱스 | 값 | 찾는 값(V) | 결과 idx |
| --- | - | ------- | ------ |
| 0   | 2 | 5       | -      |
| 1   | 7 | 5       | -      |
| 2   | 5 | 5       | 2 (찾음) |

➡️ 최종 결과 : `idx = 2`

3️⃣ 코드 예시
```python
N, V = map(int, input().split())      # 배열 크기 N, 찾는 값 V
arr = list(map(int, input().split())) # 배열 입력

idx = -1  # 기본값: 못 찾으면 -1
for i in range(N):
    if arr[i] == V:  # 찾는 값 발견
        idx = i
        break        # 첫 번째로 찾은 인덱스만 저장 후 종료

print(idx)  # 예: 2
```   
   
4️⃣ 핵심 포인트
- `break`를 사용하면 첫 번째로 찾은 인덱스만 반환.
- 찾는 값이 여러 개인 경우, 가장 **왼쪽 인덱스**가 결과로 나온다.
- 찾는 값이 없으면 `idx`는 기본값 `-1` 유지.

---

## 정렬(Sort) 알고리즘

### 정렬(Sort)이란?

- 데이터들을 **특정 기준**(<u>키</u>)에 따라 재배열하는 과정.
- 주로 오름차순(ascending) 또는 내림차순(descending)으로 재배열하는 알고리즘
- 검색, 탐색, 데이터 분석 전처리 과정에서 자주 활용됨.

### 정렬 알고리즘의 대표적인 종류
| 정렬 알고리즘                    | 특징                               | 시간 복잡도                        |
| -------------------------- | -------------------------------- | ----------------------------- |
| **버블 정렬 (Bubble Sort)**    | 인접한 두 요소를 비교하며 큰 값을 뒤로 보냄        | O(N²)                         |
| **선택 정렬 (Selection Sort)** | 가장 작은 값을 찾아서 앞쪽으로 이동             | O(N²)                         |
| **삽입 정렬 (Insertion Sort)** | 이미 정렬된 부분에 적절한 위치를 찾아 삽입         | O(N²)                         |
| **퀵 정렬 (Quick Sort)**      | 기준값(pivot)을 기준으로 분할 후 재귀적으로 정렬   | 평균: O(N log N) <br> 최악: O(N²) |
| **병합 정렬 (Merge Sort)**     | 배열을 반으로 나누고 정렬한 뒤 합치는 분할 정복 알고리즘 | O(N log N)                    |
| **카운팅 정렬 (Counting Sort)** | 정수 범위가 제한된 경우, 각 요소 개수를 세어 정렬    | O(N + K) (K: 최대값)             |

- **단순 정렬 (버블, 선택, 삽입)** 은 구현이 쉽지만 느림.
- **고급 정렬 (퀵, 병합)** 은 효율적이지만 구현 복잡도가 있음.
- **특수 정렬 (카운팅)** 은 데이터 특성이 명확할 때 유용함.
---
## 버블 정렬 (Bubble Sort)

- 인접한 두 데이터를 비교하고, 잘못된 순서라면 서로 위치를 교환하면서 정렬하는 방법.   
- 큰 값이 거품처럼 맨 뒤로 "올라간다"는 느낌이라 **버블 정렬**이라고 부른다.


### 버블 정렬 예시 (직접 손으로 정렬하기)

초기 데이터:`[55, 7, 78, 12, 42]`

1️⃣ 1회전

- 55와 7 비교 → 교환 → `[7, 55, 78, 12, 42]`
- 55와 78 비교 → 그대로
- 78과 12 비교 → 교환 → `[7, 55, 12, 78, 42]`
- 78과 42 비교 → 교환 → `[7, 55, 12, 42, 78]`

→ 가장 큰 값 78이 맨 뒤로 이동!

2️⃣ 2회전

- `[7, 55, 12, 42]`만 비교
- 55와 12 비교 → 교환 → `[7, 12, 55, 42, 78]`
- 55와 42 비교 → 교환 → `[7, 12, 42, 55, 78]`

3️⃣ 3회전

- `[7, 12, 42, 55, 78]` → 이미 정렬 완료

### 버블 정렬 알고리즘 예시

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):  # 전체 회전
        for j in range(n - 1 - i):  # 인접 비교
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

nums = [55, 7, 78, 12, 42]
print(bubble_sort(nums))  # 출력: [7, 12, 42, 55, 78]
```

### 버블 정렬 특징

- 장점: 구현이 단순하다.
- 단점: 비교와 교환이 많아서 **O(n²)** 시간 복잡도를 가진다.
- 데이터가 적을 때만 실용적.
---
##  카운팅 정렬 (Counting Sort)

**정수형 데이터**를 빠르게 정렬하는 알고리즘. 비교 없이 "숫자의 개수"를 세서 정렬한다.
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 방식
- 따라서, 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용해야함. 즉, <u>정수나 정수로 표현할 수 있는 자료에 대해서만 적용</u>이 가능하다.
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야한다.

### 카운팅 정렬 예시

데이터: `[0, 4, 1, 3, 1, 2, 4, 1]`

1️⃣ 각 숫자 개수 세기

```
숫자:    0  1  2  3  4
개수:    1  3  1  1  2
```

2️⃣ 개수만큼 순서대로 나열

- 0 → 1번
- 1 → 3번
- 2 → 1번
- 3 → 1번
- 4 → 2번

결과: `[0, 1, 1, 1, 2, 3, 4, 4]`

### 카운팅 정렬 코드

```python
def counting_sort(arr):
    max_val = max(arr)              # 1. 배열에서 가장 큰 값을 찾는다. → count 배열의 크기를 결정하기 위해 필요
    count = [0] * (max_val + 1)     # 각 숫자의 등장 횟수를 저장할 리스트 → 인덱스 번호가 정렬할 숫자 값과 대응됨

    # 1. 각 숫자의 등장 횟수 세기
    for num in arr:
        count[num] += 1

    # 2. 정렬된 결과 생성
    sorted_arr = []
    for i in range(len(count)):             # i는 숫자 값 (인덱스)
        sorted_arr.extend([i] * count[i])
    return sorted_arr

nums = [0, 4, 1, 3, 1, 2, 4, 1]
print(counting_sort(nums))  # 출력: [0, 1, 1, 1, 2, 3, 4, 4]
```

### 카운팅 정렬 특징

- 장점: 매우 빠르다 → **O(n + k)**
- 단점: 숫자의 범위(k)가 너무 크면 비효율적 (메모리 낭비)
- 문자열, 실수 정렬 불가 (정수만 가능)

---
## Exhaustive Search (완전 검색)

문제를 풀 때 가능한 모든 경우의 수를 전부 시도해보는 방법.

- Brute-force(무식한 방법)라고도 불림.
- 경우의 수가 적을 때 유용함.
- 느리지만 답을 못 찾을 가능성이 거의 없음.
- 보통 처음엔 완전 검색으로 풀어서 답을 확인한 후, 더 좋은 알고리즘으로 개선하기도 함.

### Baby-gin 게임

**문제 조건**

- 0~9 사이 숫자 카드 6장.
- **run**: 연속된 숫자 3개 (예: 456)
- **triplet**: 같은 숫자 3개 (예: 777)
- 6장이 run과 triplet으로만 구성되면 baby-gin.

예시

1. 667767 → 666, 777 → baby-gin
2. 054060 → 456, 000 → baby-gin
3. 101123 → 111, 023 → 023은 run 아님 → baby-gin 아님

### 완전 검색의 정의

#### 완전 검색

문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

> Brute-Force 혹은 generate-and-test 기법이라고도 불린다.   
> 모든 경우의 수를 테스트한 후, 최종 해법을 도출하는 방법으로   
> 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.

### 완전 검색의 필요성

- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
- 자격검정평가 등에서 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직 하다.

### 완전 검색으로 Baby-gin 접근

모든 경우를 시도해서 baby-gin인지 확인하기.

```python
from itertools import permutations

# run이나 triplet인지 체크하는 함수
def check_run_or_triplet(seq):
    if seq[0] == seq[1] == seq[2]:  # triplet
        return True
    if seq[0] + 1 == seq[1] and seq[1] + 1 == seq[2]:  # run
        return True
    return False

def is_baby_gin(numbers):
    for perm in permutations(numbers):  # 모든 순열 생성
        first, second = perm[:3], perm[3:]  # 앞 3자리, 뒤 3자리 나누기

        if check_run_or_triplet(first) and check_run_or_triplet(second):
            return True
    return False

print(is_baby_gin([6, 6, 7, 7, 6, 7]))  # 출력: True
print(is_baby_gin([0, 5, 4, 0, 6, 0]))  # 출력: True
print(is_baby_gin([1, 0, 1, 1, 2, 3]))  # 출력: False
```

✅ 완전 검색은 확실히 답을 찾지만 경우의 수가 많아질수록 느려짐.

---

### 순열(Permutation)

서로 다른 n개의 원소 중에서 r개를 골라 순서를 고려하여 나열하는 것.

서로 다른 n개 중 r개를 택하는 순열은 **<sub>n</sub>P<sub>r</sub>** 로 표현한다.

> **<sub>n</sub>P<sub>r</sub>** = n * (n-1) * (n-2) * ··· * (n-r+1)   
> **<sub>n</sub>P<sub>n</sub>** = n! 이라고 표기하며 Factorial이라 부른다.

### 단순하게 순열을 생성하는 방법
예: {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수

#### 입력

```python
for i1 in range(1, 4) :
    for i2 in range(1, 4) :
        if i2 != i1 :
            for i3 in range(1, 4) :
                if i3 != i1 and i3 != i2 :
                    print(i1, i2, i3)
```

#### 출력
```python
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

### 1️⃣ 순열 함수를 이용한 baby-gin
```python
def my_permutations(arr, r):
    result = []

    # 종료 조건: r이 0이면 더 이상 뽑을 숫자가 없으므로 빈 리스트 반환
    if r == 0:
        return [[]]

    # 배열의 각 원소를 하나씩 선택
    for i in range(len(arr)):
        remaining = arr[:i] + arr[i+1:]  # 현재 원소를 제외한 나머지 리스트
        # 나머지 리스트에서 r-1개의 순열 생성
        for perm in my_permutations(remaining, r-1):
            result.append([arr[i]] + perm)  # 현재 원소 + 나머지 순열 결합

    return result
```

### 2️⃣ run/triplet 체크 함수

중첩 함수 없이 따로 정의.

```python
def check_run_or_triplet(seq):
    if seq[0] == seq[1] == seq[2]:  # triplet
        return True
    if seq[0] + 1 == seq[1] and seq[1] + 1 == seq[2]:  # run
        return True
    return False
```

### 3️⃣ Baby-gin 판별 함수

순열 함수를 이용해서 모든 경우의 수 탐색.

```python

def is_baby_gin(numbers):
    # numbers에서 만들 수 있는 모든 6자리 순열 생성
    for perm in my_permutations(numbers, 6):
        first, second = perm[:3], perm[3:]  # 앞 3자리, 뒤 3자리 분리
        if check_run_or_triplet(first) and check_run_or_triplet(second):
            return True
    return False

# 테스트
print(is_baby_gin([6, 6, 7, 7, 6, 7]))  # 출력: True (666, 777)
print(is_baby_gin([0, 5, 4, 0, 6, 0]))  # 출력: True (000, 456)
print(is_baby_gin([1, 0, 1, 1, 2, 3]))  # 출력: False
```

### 출력

```
True
True
False
```
----

## 탐욕 알고리즘(Greedy)

- 매 순간 **가장 좋아 보이는 선택**을 하는 알고리즘.
- 부분적으로는 최적일 수 있지만, 전체적으로 항상 최적이라는 보장은 없음.
- 구현이 간단하고 빠름. (일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근임)

### 탐욕 알고리즘 과정

1) 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합(Solution Set)에 추가한다.
2) 실행 가능성 검사 : 새로운 부분 해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
3) 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 `1)`의 해 선택부터 다시 시작한다.


### Baby-gin 탐욕 알고리즘 접근

아이디어:

1. 숫자들을 정렬.
2. 앞에서부터 `triplet` 먼저 체크 → 있으면 제거.
3. 없으면 `run` 체크 → 있으면 제거.
4. 두 번 반복해서 다 제거되면 baby-gin.

### 코드 구현

```python
def is_baby_gin_greedy(numbers):
    # 0~9 숫자의 개수를 세는 카운팅 배열
    c = [0] * 10
    for num in numbers:
        c[num] += 1

    tri = 0  # triplet 개수
    run = 0  # run 개수
    i = 0

    while i < 10:
        # 1. triplet 검사
        if c[i] >= 3:
            c[i] -= 3
            tri += 1
            continue  # 같은 위치 다시 검사 (중복 triplet 방지)

        # 2. run 검사
        if i <= 7 and c[i] >= 1 and c[i + 1] >= 1 and c[i + 2] >= 1:
            c[i] -= 1
            c[i + 1] -= 1
            c[i + 2] -= 1
            run += 1
            continue  # 같은 위치 다시 검사 (중복 run 방지)

        i += 1  # 다음 숫자로 이동

    return run + tri == 2  # run 2개 or triplet 2개 or run+triplet 조합
```

### 테스트

```python
print(is_baby_gin_greedy([6, 6, 7, 7, 6, 7]))  # 출력: True
print(is_baby_gin_greedy([0, 5, 4, 0, 6, 0]))  # 출력: True
print(is_baby_gin_greedy([1, 0, 1, 1, 2, 3]))  # 출력: False
```

### 출력

```
True
True
False
```


