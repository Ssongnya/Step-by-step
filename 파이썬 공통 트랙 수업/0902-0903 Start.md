# 시작하기

## SW 문제해결

### SW 문제해결 역량이란?

프로그램을 하기 위한 많은 제약 조건과 요구 사항을 이해하고 최선의 방법을 찾아내는 능력

- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있음

-  문제해결 역량은 추상적인 기술임
  - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없다.
  - 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않는다.

- 문제해결 역량을 향상시키기 위해서 훈련이 필요하다.

### 문제해결 과정

1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개설할 방법이 있는지 찾아본다.

### 리스트에 숫자 넣기

1. 수 N을 입력 받는다.
2. 윗 줄에는 N부터 1씩 증가되는 숫자 4개를 왼쪽에 채운다.
3. 아랫 줄에는 N부터 1씩 감소되는 숫자 4개를 오른쪽에 채운다.
4. 최종 결과를 출력한다. 빈 공간은 0으로 출력한다.

#### 설계 예시

1. `2 X 7` 크기의 0으로 채운 리스트를 준비한다.
2. 수 N을 입력 받는다.
3. t1 = N 대입 후, for문을 4번 돌려 t1 값을 리스트에 넣는다. `range(0, 4)`
4. t2 = N 대입 후, for문을 4번 돌려 t2 값을 리스트에 넣는다. `range(6, 2, -1)`


## 복잡도 분석

### 알고리즘이란?

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법 
  - 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다.
- 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차라고 볼 수 있다.
- 1부터 100까지의 합을 구하는 두 가지 알고리즘의 예

### 알고리즘의 효율

- 공간적 효율성과 시간적 효율성
  - 공간적 효율성은 알고리즘이 필요로 하는 메모리 공간을 말한다.
  - 시간적 효율성은 알고리즘이 작업을 완료하는 데 걸리는 시간을 말한다.
  - 효율성을 뒤집어 표현하면 복잡도(Complexity)가 된다. 
  - 복잡도가 높을수록 효율성은 저하된다.

> 시간적 효율성은 주로 입력 크기 n에 대한 연산 횟수로 나타낸다.

### 복잡도의 점근적 표기

- 시간(또는 공간) 복잡도는 입력 크기에 대한 함수로 표기
  - 이 함수는 주로 여러 개의 항을 가지는 다항식이다.
  - 이를 단순한 함수로 표현하기 위해 점근적 표기를 사용한다.

- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법
  - **O(Big-Oh)-표기**
  - Ω(Big-Omega)-표기
  - Θ(Big-Theta)-표기

### 아래 코드는 몇 번 반복될까?
```python
n = int(input())

for i in range(n):
  print(i, end = '')
```

### O(Big-Oh) - 표기

- O-표기는 복잡도의 점근적 상한을 나타냄
- 복잡도가 f(n) = 2n<sup>2</sup> - 7n + 4 라면, f(n)의 O-표기는 O(n<sup>2</sup>)
- 먼저 f(n)의 단순화된 표현은 n<sup>2</sup>
- 단순화된 함수 n<sup>2</sup>에 임의의 상수 c를 곱한 cn<sup>2</sup>이 n이 증가함에 따라 f(n)의 상한이 된다.(단, c > 0)


### O(n)
```python
n = int(input())

for i in range(n):
  print(i, end = '')

for i in range(n):
  print(i, end = '')

for i in range(n):
  print(i, end = '')
```

### O(n<sup>2</sup>)
```python
n = int(input())

for i in range(n):
    for x in range(n):
      print(i, end = '')

    for y in range(n):
      print(i, end = '')
```

### O(1)
```python
n = int(input())

for i in range(50):
  print(i)
```

### 빅오표기법 표현 방법

`O(5N)`같이 정확한 배수를 강조하고 싶은 경우라면 `O(N)`대신 배수를 포함하여 표현할 수 있다.

### 빅오표기법으로 성능 비교하기

O(N) VS O(N<sup>2</sup>)   
   
-> N의 크기마다 달라서 그때마다 성능이 좋은 건 다르다

### 효율적인 알고리즘이 왜 필요할까?

- 10억 개의 숫자를 정렬하는데 PC에서 O(n<sup>2</sup>) 알고리즘은 300여 년이 걸리는 반면에 O(nlogn) 알고리즘은 5분 만에 정렬함.

  | 시간복잡도 | 입력 크기 | PC 실행 시간 | 슈퍼컴 실행 시간 |
  |------------|-----------|--------------|------------------|
  | **O(n²)**  | 1,000     | < 1초        | < 1초            |
  |            | 1백만     | 2시간        | 1초              |
  |            | 10억      | 300년        | 1주일            |
  | **O(n log n)** | 1,000  | < 1초        | < 1초            |
  |            | 1백만     | < 1초        | < 1초            |
  |            | 10억      | 5분          | < 1초            |



# 진법과 연산

## 진법

### 2진수, 8진수, 10진수, 16진수

- **10진수 : 사람이 사용하는 진수**, 수 하나를 0 ~ 9로 표현 (168)
- **2진수 : 컴퓨터가 사용하는 진수**, 수 하나를 0, 1로 표현 (1010 1000)
- 8진수 : 2진수를 더 가독성 있게 사용 (250)
- **16진수 : 2진수를 더 가독성 있게 사용**, 수 하나를 0, 1, ··· 8, 9, A, B, C, D, E, F 로 표현 (A8)

### 왜 16진수를 사용하는 것인가?

- 2진수를 사람이 이해하기 편하도록, 10진수로 변환 시
  - 인간이 이해하기 편하지만, 연산이 오래 걸림

- 2진수를 사람이 이해하기 편하도록 16진수로 변환 시
  - 인간이 이해하기 어렵지만, 연산 속도가 매우 빠름

### 용어

- `HEX` : 16진수
- `DEC` : 10진수
- `OCT` : 8진수
- `BIN` : 2진수



## 진법 변환

### 10진수 → 타 진수로 변환

- 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.
- 10진수 149

#### 2진수로 변환

| 몫            | 나머지 |
| ------------ | --- |
| 149 ÷ 2 = 74 | 1   |
| 74 ÷ 2 = 37  | 0   |
| 37 ÷ 2 = 18  | 1   |
| 18 ÷ 2 = 9   | 0   |
| 9 ÷ 2 = 4    | 1   |
| 4 ÷ 2 = 2    | 0   |
| 2 ÷ 2 = 1    | 0   |
| 1 ÷ 2 = 0    | 1   |

👉 나머지를 거꾸로 읽기 → 10010101   
✅ 따라서, 149(10) = 10010101(2)

#### 8진수로 변환

| 몫            | 나머지 |
| ------------ | --- |
| 149 ÷ 8 = 18 | 5   |
| 18 ÷ 8 = 2   | 2   |
| 2 ÷ 8 = 0    | 2   |

👉 나머지를 거꾸로 읽기 → 225   
✅ 따라서, 149(10) = 225(8)

#### 16진수로 변환

| 몫            | 나머지 |
| ------------ | --- |
| 149 ÷ 16 = 9 | 5   |
| 9 ÷ 16 = 0   | 9   |

👉 나머지를 거꾸로 읽기 → 95   
✅ 따라서, 149(10) = 95(16)


### 코드로 2진수 변환 구현

```python
tar = 149
result = []

while tar != 0:
  result.append(tar % 2)
  tar //= 2   # 10진수를 지속적으로 2로 나누어 구현

result.reverse() # 마지막으로 List를 거꾸로 뒤집기
print(result)
```

### 2진수를 10진수로 변환

2진수는 각 자릿수를 **2의 거듭제곱**으로 환산해서 모두 더하면 10진수가 된다.

#### (10110)₂를 10진수로 변환
```
(10110)₂
= (1 × 2⁴) + (0 × 2³) + (1 × 2²) + (1 × 2¹) + (0 × 2⁰)
= (16) + (0) + (4) + (2) + (0)
= 22
```

### 16진수와 2진수 변환

- `2진수&10진수`간 변환은 연산이 많으나, `2진수&16진수`간 변환은 연산이 없음

- 진법 변환을 빠르게 할 수 있으면 다음 진수 표를 암기하는 것을 권장함

| 2진수 | 10진수 | 16진수 |
|-------|--------|--------|
| 0000  | 0      | 0      |
| 0001  | 1      | 1      |
| 0010  | 2      | 2      |
| 0011  | 3      | 3      |
| 0100  | 4      | 4      |
| 0101  | 5      | 5      |
| 0110  | 6      | 6      |
| 0111  | 7      | 7      |
| 1000  | 8      | 8      |
| 1001  | 9      | 9      |
| 1010  | 10     | a      |
| 1011  | 11     | b      |
| 1100  | 12     | c      |
| 1101  | 13     | d      |
| 1110  | 14     | e      |
| 1111  | 15     | f      |

### 진수표를 이용해서 `0xF9`를 2진수로 변환해보기

0x는 **"이 뒤의 숫자가 16진수다"** 라는 걸 표시하는 **접두사(prefix)**

1. **원리**  
   - 16진수 한 자리 = 2진수 네 자리(4비트)와 대응한다.  
   - 따라서 `F9(16)`은 `F`와 `9`를 각각 2진수로 변환한 뒤 이어 붙이면 된다.  

2. **진수표 참고**  
   - `F(16) = 1111(2)`  
   - `9(16) = 1001(2)`  

3. **합치기**  


4. **최종 결과**  
✅ `(0xF9)₁₆ = (11111001)₂`


### 16진수를 입력 받으면, 2진수로 출력해주는 프로그램

```python
# 16진수 한 자리 → 2진수 4자리 변환표 (딕셔너리)
hex_to_bin = {
    '0': '0000', '1': '0001', '2': '0010', '3': '0011',
    '4': '0100', '5': '0101', '6': '0110', '7': '0111',
    '8': '1000', '9': '1001', 'A': '1010', 'B': '1011',
    'C': '1100', 'D': '1101', 'E': '1110', 'F': '1111'
}

# 사용자 입력 (예: F9)
hex_num = input("16진수를 입력하세요 (예: F9): ").upper()  
# 대문자로 변환해서 처리

binary_result = ""  # 최종 결과 문자열

# for문으로 한 글자씩 변환
for digit in hex_num:
    binary_result += hex_to_bin[digit]

print(f"{hex_num}(16) = {binary_result}(2)")
```

### 0과 1로 이루어진 1차 배열에서 7개씩 수를 묶어, 10진수로 출력하기

우리가 흔히 쓰는 ASCII 코드는 한 문자를 **7비트(= 7자리 2진수)**로 표현한다.

- ex
  - A = 1000001 (65)
  - B = 1000010 (66)
  - a = 1100001 (97)

즉, 7자리 이진수 → 10진수로 바꾸면 해당 문자 코드 값이 된다.

#### 이진수 → 10진수 바꿔보기

[예시 1]

00000010001101   
→ 0000001 | 0001101

1. `0000001`   
    = 1 × 2⁰ = 1

2. `0001101`   
= (1×2³) + (1×2²) + (0×2¹) + (1×2⁰)   
= 8 + 4 + 0 + 1 = **13**

3. 00000010001101 → 1, 13
   
[예시 2]

```
입력 
000000011110000011000001111001100001100011111011111011100111

7개씩 끊기
0000000 / 1111000 / 0001100 / 0001111 / 0011000 / 0110001 / 1111011 / 1110111 / 00111

각각 10진수로 바꾸기
0, 120, 12, 7, 76, 24, 60, 121, 124, 103
```

```python
def binary_to_decimal(binary_str):
    decimal_number = 0
    power = 0

    # 뒤에서부터 각 자리의 숫자를 10진수로 변환
    for digit in reversed(binary_str):
        if digit == '1':
            decimal_number += 2 ** power
        power += 1

    return decimal_number


word = input().strip()

for i in range(0, len(word), 7):
    print(binary_to_decimal(word[i:i+7]), end=' ')
```
## 비트연산

### 비트와 바이트

- 1 bit : 0과 1을 표현하는 정보의 단위
- 1 Byte : 8-bit를 묶어 1 Byte라고 함 (메모리 주소가 부여되는 단위)

### 비트 연산

컴퓨터의 CPU 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈 등을 계산함

- 비트 연산 챕터의 목적
    - 사람이 사용하는 사칙연산( +, *, /, -)이 아닌 컴퓨터가 사용하는 연산인 "비트 연산"을 이해해본다
    - 더 나아가, 프로그래밍에서 비트연산을 활용한 코딩 방법을 익혀본다.

### AND와 OR 비트연산자 이해하기

- a AND b : a, b 둘 다 1일 때만 결과가 1, 그 외에는 0
- a OR b : a, b 둘 중 하나만 1이면 결과가 1, 그 외에는 0

|연산자|연산자의 기능|
|-----|-----------|
|`&`|비트단위로 AND연산을 한다. 예) `num1 & num2`|
|`\|`|비트단위로 OR연산을 한다. 예) `num1 \| num2`|

#### 7 & 5 = ?, 7 | 5 = ?

- 이진수로 표현한다면 `0b111 & 0b101`, `0b111 | 0b101`
- AND연산
  ```
  # 둘 다 1일 때만 1

    111   (7)
  & 101   (5)
  ------
    101   (10진수 5)
  ```
- OR연산
  ```
  # 하나만 1이어도 1

    111   (7)
  | 101   (5)
  ------
    111   (10진수 7)
  ```

### 파이썬에서 진법 변환 (2진수, 16진수, 10진수)
- **2진수**: 숫자 앞에 `0b` 붙여 표현  
- **16진수**: 숫자 앞에 `0x` 붙여 표현  

---

#### 1️⃣ 10진수를 2진수, 16진수로 변환
```python
print(bin(10))   # 10진수 → 2진수
print(hex(10))   # 10진수 → 16진수
```
출력
```
0b1010
0xa
```
#### 2️⃣ 10진수를 2진수, 16진수로 변환
```python
print(int('1011', 2))  # 2진수 문자열 → 10진수
print(int('b', 16))    # 16진수 문자열 → 10진수
```
출력
```
11
11
```

`bin(x)` → 10진수 → 2진수 문자열 변환 (`0b` 접두사)

`hex(x)` → 10진수 → 16진수 문자열 변환 (`0x` 접두사)

`int(str, base)` → 문자열을 주어진 진법(base)의 10진수 정수로 변환


### XOR 연산자와 NOT 연산자 응용

1. XOR 연산자
- 기호: `^`
- 규칙: 두 비트가 같으면 0, 다르면 1
  - 1 ^ 1 = 0  
  - 0 ^ 0 = 0  
  - 1 ^ 0 = 1  
  - 0 ^ 1 = 1  

### 예시
```python
a = bin(0b1011 ^ 0b1101)
print(a)  # 0b110
```
2. 신기한 XOR의 성질

어떤 수 `x`에 대해 같은 값 `k`로 XOR을 두 번 하면 다시 원래 값이 된다. 즉, `(x ^ k) ^ k = x`
```
7070 ^ 1004 = 6258
6258 ^ 1004 = 7070

  1101110011110   (7070)
^    1111101100   (1004)
----------------
  1100001110010   (6258)

```
- 원래 값 복원 가능 → 간단한 암호화/복호화 방식으로 사용됨.

### 비트 연산자 (Shift)

- **Left Shift (<<)** : 비트를 왼쪽으로 밀어냄 → 값이 2배씩 커짐
- **Right Shift (>>)** : 비트를 오른쪽으로 밀어냄 → 값이 1/2씩 줄어듦 (오른쪽 비트는 제거됨)

| 연산자 | 기능 |
|--------|------|
| `<<` | 피연산자의 비트를 **왼쪽**으로 이동 |
| `>>` | 피연산자의 비트를 **오른쪽**으로 이동 |


#### Left/Right Shift 예시
```python
print(bin(0b1101 << 2))  # 0b110100
print(bin(0b1101 >> 2))  # 0b11
```


### 💻 [도전] Left Shift (<<) 프로그래밍

#### 문제
반복문을 이용하여 다음과 같이 출력하시오.  
- Loop 1: `0b1` (2진수와 10진수 출력)  
- Loop 2: `0b10`  
- Loop 3: `0b100`  
- Loop 4: `0b1000`  
- Loop 5: `0b10000`  

#### 파이썬 코드
```python
for i in range(5):
    value = 1 << i   # 1을 왼쪽으로 i번 이동
    print(bin(value), value)
```

## 비트 연산 응용 & 2의 보수

### 1️⃣ 비트 연산 응용 1
- `1 << n`  
  → 값은 **2ⁿ**  
- 임베디드 분야에서 빠른 계산을 위해 자주 사용  


### 2️⃣ 비트 연산 응용 2
- `i & (1 << n)`  
  → i의 **n번째 비트가 1인지 확인** 가능  
- 예시
  ```python
  i = 0b1101 (13)
  i & (1 << 2) = 0b0100 (4)
  ```
  - `1 << n`   
    → 1을 왼쪽으로 n칸 밀어낸 값   
    → 즉, n번째 비트만 1이고 나머지는 모두 0인 값

  - `1 << 2 = 0b100   (4)`   
    → 2번째 비트만 켜져 있는 비트 마스크

  - 즉, i & (1 << n) 은 결과가 **0보다 크면** → n번째 비트가 `1`, 결과가 0이면 → n번째 비트가 `0`   
    → 특정 비트가 켜져 있는지(1인지) 확인할 수 있는 방법

### 3️⃣ 2의 보수 (Two’s Complement)

#### 음수 표현 방법

- 컴퓨터는 음수를 **2의 보수** 방식으로 관리한다.  
- 맨 앞자리 비트 (**MSB, Most Significant Bit**)는 **부호 비트**로 사용된다.  
  - `0` → 양수  
  - `1` → 음수  

#### 컴퓨터가 2의 보수를 사용하는 이유
- **연산 속도 향상** : 덧셈/뺄셈을 같은 방식으로 처리 가능  
- **+0과 -0을 구분할 필요 없음** : 0은 하나만 존재  
- 파이썬 예제 코드
  ```python
  def bit_print(i):
      output = ''
      for j in range(7, -1, -1):    # 8비트 기준
          output += '1' if i & (1 << j) else '0'
      print(output)

  for i in range(-5, 6):
      print(f"{i} = ", end='')
      bit_print(i)
  ```
양수: 일반적인 2진수 그대로 저장

음수: 양수 값을 **2의 보수(비트 반전 후 +1)**로 변환하여 저장

이 방식 덕분에 컴퓨터는 음수 연산도 단순하게 처리할 수 있음

- 구하는 방법
  1. 수를 **모두 뒤집음** (0 ↔ 1)  
  2. +1을 더함  

-  예시
  ```
  10001의 2의 보수
  → 01110 + 1 = 01111
  ```