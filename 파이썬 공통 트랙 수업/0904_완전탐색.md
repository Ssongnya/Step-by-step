# 완전 탐색

## 반복과 재귀

### 반복과 재귀는 유사한 작업을 수행할 수 있다.

#### 반복

수행하는 작업이 완료될 때까지 계속 반복한다.
  - 루프 (for, while 구조)
  - **반복문은 코드를 n번 반복시킬 수 있음**

#### 재귀

주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  - 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합
  - **재귀호출은 n중 반복문과 같은 효과**

### 반복문 실습

#### 1, 2, 3으로 만들 수 있는 두 자릿수 만들기
```
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
```

이 문제를 반복문을 이용해서 구현한다면?

→ 2중 for문으로 구현
```python
for a in range(1, 4):
  for b in range(1, 4):
    print(a, b)
```

#### 1, 2, 3을 이용한 네 자릿수를 출력하는 코드 작성(과제)

→ 4중 for문으로 구현
```python
for a in range(1, 4):
  for b in range(1, 4):
    for c in range(1, 4):
      for d in range(1, 4):
        print(a, b, c, d)
```

### N을 입력 받아 1, 2, 3을 사용하는 N자릿수 만들기

- 만약 N = 2 → `11 ~ 33` 까지 출력
- 만약 N = 3 → `111 ~ 333` 까지 출력
- 만약 N = 4 → `1111 ~ 3333` 까지 출력   
...
- 만약 N = 9 → `111111111 ~ 999999999` 까지 출력

>위 문제를 반복문을 이용해서 구현할 수 있을까?

>구현할 수 있다면, 몇 중 for문을 작성해야 할까?

### 재귀 호출로 N중 for문 구현

N 입력 후 `111··· ~ 333···` 출력하는 문제는 단순히 for문으로는 구현이 어려움.

따라서 재귀호출을 사용하면 간단하게 구현할 수 있다.

```python
path = []   # 현재까지 선택된 숫자들을 저장할 리스트
N = 3       # 만들 숫자의 자리 수

def run(lev):
    if lev == N:          # 종료 조건: 길이가 N에 도달하면 출력
        print(path)
        return
    
    for i in range(1, 4): # 1, 2, 3 반복
        path.append(i)    # 현재 숫자 추가
        run(lev + 1)      # 다음 자리로 이동
        path.pop()        # 백트래킹(마지막 원소 제거)

# 실행
# N = int(input())
run(0)
```

### 재귀 연습 전, 알아야 할 함수의 특징 1

- KFC 함수를 호출할 때, int 타입 객체를 전달하면 **값만 복사됨**
- 아래 예시에서, main 함수의 x와, KFC함수의 x는 서로 다른 객체
  - 마치 한국 사는 KIM과, 미국 사는 KIM이 이름만 같고, 서로 다른 사람인 것과 같다.

```python
def KFC(x):
    print(x)
    x += 1
    print(x)

x = 3
KFC(x + 1)
print(x)
```
- 실행과정
  - x = 3
  - KFC(x + 1) → x + 1 = 4 전달
  - 함수 내부 첫 번째 print(x) → 4 출력
  - x += 1 → 내부의 x가 5로 변경
  - 함수 내부 두 번째 print(x) → 5 출력
  - 함수 종료 후 print(x) → 전역 변수 x = 3 그대로 출력

- 실행 결과
  ```python
  4
  5
  3
  ```

### 재귀 연습 전, 알아야 할 함수의 특징 2

 BTS 함수가 끝나면 Main으로 바로 돌아오는 것이 아님

→ **해당 함수를 호출했던 코드 위치로 돌아감**

즉, 호출한 지점 다음 줄부터 이어서 실행됨.


#### 아래 코드 실행 결과는?
```python
def BBQ(x):
    x += 10
    print(x)

def KFC(x):
    print(x)
    x += 3
    BBQ(x + 2)
    print(x)

x = 3
KFC(x + 1)
print(x)
```

- 실행과정

**Main 실행**

`x = 3`

`KFC(x + 1)` → `KFC(4)` 호출

**KFC(4) 실행**

`print(x)` → `4` 출력

`x += 3` → 내부 `x = 7`

`BBQ(x + 2)` → `BBQ(9)` 호출

**BBQ(9) 실행**

`x += 10` → 내부 `x = 19`

`print(x)` → `19` 출력

종료 후 다시 **<u>KFC 함수 호출 지점으로 복귀</u>**

**KFC 함수 이어서 실행**

`print(x)` → `7` 출력

종료 후 다시 **Main으로 복귀**

**Main 이어서 실행**

`print(x)` → `3` 출력

### 무한 재귀호출
```python
def KFC(x):
    print(x)
    KFC(x + 1)   # 자기 자신을 다시 호출 (재귀)

KFC(0)
print("끝")
```

`print("끝")` 은 실행되지 않음 → 함수가 끝나지 않고 계속 호출되기 때문.

### 재귀호출 공부의 시작은, 무한 재귀호출을 막는 것 부터 시작

재귀 호출을 사용할 때는 반드시 기저조건(base case) 을 설정해야 한다.
- 기저조건이 없다면 → 무한 재귀 호출 발생 → 프로그램 에러

```python
def KFC(x):
    if x == 2:      # 기저조건 (종료 조건)
        return
    print(x)
    KFC(x + 1)
    print(x)

KFC(0)
print("끝")
```

- 해당 코드의 `if문`을 **"기저조건 (base case)"** 이라고 한다.

### 재귀호출 실습

`0 1 2 3 4 5 5 4 3 2 1 0`을 재귀호출을 이용하여 구현
```python
def SSONG(x):
    if x > 5:
        return
    print(x)  
    SSONG(x + 1)
    print(x)

SSONG(0)
```

### 재귀호출 코드가 2개, 간략화 하여 그리기 1

하나의 함수(KFC) 내부에 **재귀 호출 코드가 2개** 들어가면 → **재귀 호출 트리**가 만들어짐.

즉, 각 호출에서 다시 **두 갈래로 분기**하면서 호출이 확산됨.

```
Main
└── KFC(0)
    ├── KFC(1)
    │   ├── KFC(2)
    │   └── KFC(2)
    └── KFC(1)
        ├── KFC(2)
        └── KFC(2)
```


### 재귀호출 코드가 2개 간략화 하여 그리기 2

**재귀 호출 트리 그림만 보고도 코드를 구현할 수 있어야 한다.**

```python
def KFC(x):
    if x == 제한값:    # 기저조건
        return
    KFC(x + 1)         # 첫 번째 재귀 호출
    KFC(x + 1)         # 두 번째 재귀 호출

# Main
KFC(0)
```

### 재귀의 깊이 : Level

**Level**: 재귀 호출의 깊이

**Branch(나뭇가지 수)**: 한 번에 몇 개의 재귀 호출이 분기되는지

- ex) Level은 3, Branch(나뭇가지)는 4인 형태의 코드

```python
def KFC(x):
    if x == 3:       # 기저조건 (깊이 제한)
        return
    KFC(x + 1)
    KFC(x + 1)
    KFC(x + 1)
    KFC(x + 1)

KFC(0)
```

- for문으로도 표현 가능

```python
def KFC(x):
    if x == 3:       # Level 제한
        return
    for i in range(1, 4+1):   # Branch = 4
        KFC(x + 1)

KFC(0)
```

### 재귀호출을 이용한 코딩 기법 학습

- 반드시 위의 for문의 원리를 이해해야한다.
  - 이해됐다면, **순열**을 학습할 준비 완료! 


## 순열

### 순열이란?

서로 다른 N개에서, R개를 중복 없이, 순서를 고려하여 나열하는 것

- 예시

카드: `[0] [1] [2]` (3장의 카드)

이 중에서 2장을 뽑아 순열을 나열하면:
```
[0 1]
[0 2]
[1 0]
[1 2]
[2 0]
[2 1]
```

- 특징

순열은 순서를 고려한다.

따라서 [0 1] 과 [1 0] 은 서로 다른 경우로 취급된다.

**<u>순열은 중복을 취급하지 않는다.</u>**

### 중복 순열이란?

서로 다른 N개에서, R개를 **중복을 허용하고**, 순서를 고려하여 나열하는 것


- 예시

카드: `[0] [1] [2]` (3장의 카드)

이 중에서 2장을 뽑아 중복순열을 나열하면:

```
[0 0]
[0 1]
[0 2]
[1 0]
[1 1]
[1 2]
[2 0]
[2 1]
[2 2]
```

- 특징

순서를 고려한다.

하지만, 중복 허용 → 같은 숫자를 여러 번 선택할 수 있다.

따라서 `[0 0], [1 1], [2 2]` 와 같은 경우도 포함됨.

### 중복순열 구현 원리

1. 재귀호출을 할 때 마다, **이동 경로를 흔적으로 남김**
2. **가장 마지막 레벨에 도착했을 때, 이동 경로를 출력**


### 순열 코드 구현

1. 먼저 `path`라는 전역 리스트를 준비한다.
  - 선택한 숫자들을 기록하는 리스트

  - `Level = 2`, `Branch = 3`(0, 1, 2 선택 가능)으로 동작하는 재귀 코드 구현

    ```python
    path = []

    def KFC(x):
        if x == 2:   # 기저조건
            return
        for i in range(3):
            KFC(x + 1)

    KFC(0)
    ```
2. 이동 경로 기록 (`append`추가)
  - 재귀 호출을 하기 직전에 `path.append(i)` 수행
  - 이동한 숫자를 기록한다.
    ```python
    for i in range(3):
      path.append(i)   # 경로 기록코드 추가
      KFC(x + 1)
    ```

3. 경로누적
  - `append`가 반복 실행되면서 `path`가 점점 쌓임

4. 출력 코드 추가
  - 기저조건 (`if x == 2`)에 도달하면 `print(path)` 실행
    ```python
    def KFC(x):
      if x == 2:
          print(path)   # 출력 코드 추가
          return
      for i in range(3):
          path.append(i)
          KFC(x + 1)
    ```
5. 백트래킹 (`pop` 추가)

  - 재귀 호출이 끝난 뒤 `path.pop()`을 실행해준다
  - 마지막에 추가된 원소를 제거하여 **경로 원상복구**
    ```python
    for i in range(3):
    path.append(i)
    KFC(x + 1)
    path.pop()    # 백트래킹
    ```

6. 최종코드
    ```python
    path = []
    def KFC(x):
        if x == 2:          # Level 2에서 종료
            print(path)
            return
        for i in range(3):  # Branch 3 (0, 1, 2)
            path.append(i)  # 이동 기록
            KFC(x + 1)      # 다음 단계 재귀 호출
            path.pop()      # 원상복구

    KFC(0)
    ```

#### [도전] 1부터 6까지 사요하는 중복순열 출력
```python
def ssong(x):
    if x == 3:
        print(path)
        return

    for i in range(1, 7):
        path.append(i)
        ssong(x + 1)
        path.pop()

path = []

ssong(0)
```

### 중복을 취급하지 않는 "<u>순열</u>" 구현 방법

1. 중복순열 코드를 작성
2. **중복을 제거하는 코드**를 추가하면 순열 코드가 됨

### 중복을 제거하는 원리

- **전역 리스트** 사용으로 이미 선택했던 숫자인지 아닌지 구분
- 이를 used 배열 또는 visited 배열이라고 부름
  - DFS, BFS에 사용되는 것과 같다.

### 중복을 제거한 순열 생성 예시

- 0을 선택하고 재귀호출 한 후에는, **또다시 0을 선택하지 못하도록 막아햐 함**
- **재귀 호출을 하기 직전**, 이미 선택했던 숫자인지 아닌지 검사하는 코드가 필요

### 중복 제거 순열 코드 구현 (0, 1, 2 순열)

- 이미 사용한 숫자인지 아닌지 구분하는 List 준비하기
  - 전역으로 used라는 리스트를 준비한다.
  - `used = [False, False, False]`
  
- **이미 사용한 숫자인지 아닌지 검사해주는 소스코드 추가**

  ```python
  def ssong(x):
    if x == 2:
      print(path)
      return

    for i in range(3):
      if used[i] == True: # 이미 사용했다면 다음 요소로 넘어감
        continue
      used[i] = True  # 사용 시 사용체크
      path.append(i)
      ssong(x + 1)
      path.pop()
      used[i] = False # 백트래킹 주의

  path = []

  ssong(0)
  ```

  ### [도전과제] 중복순열과 순열 구현하기

  1) 중복 순열
  ```python
  def dice(x):
    
    if x == 2:
        print(choice)
        return
    
    for i in range(1, 7):
        choice.append(i)
        dice(x + 1)
        choice.pop()

  choice = []

  dice(0)
  ```

  2) 순열

  ```python
  def dice(x):
    
    if x == 2:
        print(choice)
        return
    
    for i in range(1, 7):
        if used[i]:
            continue

        choice.append(i)
        used[i] = True

        dice(x + 1)

        choice.pop()
        used[i] = False

  choice = []
  used = [False for _ in range(7)]

  dice(0)
  ```

## 완전 탐색
## Brute-Force (부르트 포스 알고리즘)

모든 가능한 경우를 모두 시도를 해보아 정답을 찾아내는 알고리즘

### 완전 탐색 예시

- 자전거 열쇠 비밀번호 맞추기
- 만약 1 ~ 9까지 이뤄진, N자리 숫자를 맞춰야한다면?
  - 순열 코드(재귀호출)로 구현하여, 모두 시도..!

### 완전 탐색 문제 "1. 주사위 눈의 합"

- 3개의 주사위를 던져 나올 수 있는 중복 순열에 대해, 합이 10 이하가 나오는 경우는 총 몇가지 인가?

> 가능한 모든 케이스를 탐색해야하는 완전탐색 알고리즘 문제

1) 먼저 합을 출력하는 코드를 작성한다.
  - 재귀호출을 할 때 마다 선택한 값의 **누적 합**을 구함
  - 파라미터에 `sum`을 추가하여 구현
    - `sum` : 지금까지 구한 합
    - `i` : 선택한 주사위 눈금
  - 재귀호출 할 때 <u>`sum + i`</u> 값을 전달

  ```python
  path = []

  def ssong(x, sum)   # sum 인자 추가
    if x == 3:
      print(f"{path} = {sum}")
      return
    
    for i in range(1, 7):
      path.append(i)
      ssong(x + 1, sum + i)
      path.pop()
    
  ssong(x = 0, sum = 0)
  ```

2) `sum`이 10 이하 일 때만 출력하도록 코드 추가
    - 실제로는 모두 탐색하지만, 출력만 하지 않는 방법
    - **가지치기가 아니라** 출력만 숨기는 것이라 느린 성능을 띤다

  ```python
  path = []

  def ssong(x, sum)
    if x == 3:
      if sum <= 10:  # 10이하 조건 추가
        print(f"{path} = {sum}")
      return
    
    for i in range(1, 7):
      path.append(i)
      ssong(x + 1, sum + i)
      path.pop()
    
  ssong(x = 0, sum = 0)
  ```

3) 더욱 빠른 성능을 위해서라면 가지치기 방식을 택한다.

  ```python
  path = []

  def ssong(x, sum)
    if sum > 10:    # 가지치기
      return
    if x == 3:
      print(f"{path} = {sum}")
      return
    
    for i in range(1, 7):
      path.append(i)
      ssong(x + 1, sum + i)
      path.pop()
    
  ssong(x = 0, sum = 0)
  ```

4) 몇 가지인지 가짓수를 세기 위해서 cnt += 1 코드를 추가해준다.

  ```python
  path = []
  cnt = 0

  def ssong(x, sum)
    global cnt  # 전역 변수 cnt 선언
    if sum > 10:
      return
    if x == 3:
      print(f"{path} = {sum}")
      cnt += 1    # 발견 시 마다 +1
      return
    
    for i in range(1, 7):
      path.append(i)
      ssong(x + 1, sum + i)
      path.pop()
    
  ssong(x = 0, sum = 0)
  ```
### 완전탐색 문제 2. 연속 3장의 트럼프 카드

A, J, Q, K 네 종류의 카드들이 충분히 있다. 이 중, 5장의 카드를 뽑아 나열할 때, 

같은 종류의 카드가 **세 장 연속**으로 나오는 경우의 수는?

1) 순열 코드 작성
  ```python
  cards = ['A', 'J', 'Q', 'K']
  path = []

  def trump(x):
      if x == 5:
          print(path)
          return

      for i in range(4):
          path.append(cards[i])
          trump(x + 1)
          path.pop()

  trump(0)
  ```
2) 같은 종류의 카드가 연속 세 장 나왔다면 counting

- 같은 카드가 연속 세 장인지 검색하는 함수를 추가한다.

  ```python
  def cnt_three():
    if path[0] == path[1] == path[2]: return True
    if path[1] == path[2] == path[3]: return True
    if path[2] == path[3] == path[4]: return True
    return False
  ```

3) 전체 코드

```python
cards = ['A', 'J', 'Q', 'K']
path = []
cnt = 0

    def cnt_three():
        if path[0] == path[1] == path[2]: return True
        if path[1] == path[2] == path[3]: return True
        if path[2] == path[3] == path[4]: return True
        return False

    def trump(x):
        global cnt

        if x == 5:
            if cnt_three():
                cnt += 1
              return

        for i in range(4):
            path.append(cards[i])
            trump(x + 1)
            path.pop()
trump(0)
print(cnt)
```
