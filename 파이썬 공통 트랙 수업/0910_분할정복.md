# 분할 정복

## 분할 정복 기법

문제를 작은 하위 문제로 나누고(분할) 각각을 해결(정복)한 뒤,   
그 결과를 결합(통합)하여 원래 문제를 해결하는 알고리즘 기법

### 분할 정복 기법의 설계 전략

- 분할(Divide) : 해결할 문제를 여러 개의 작은 부분으로 나눔
- 정복(Conquer) : 나눈 작은 문제를 각각 해결
- 통합(Combine) : (필요하다면) 해결된 해답을 모음


### 분할 정복 기법의 구조
- **Top-down approach 예시**

- 흐름도
1. **문제의 크기 n**
   - 크기 n/2인 부분 문제 1
   - 크기 n/2인 부분 문제 2

2. **분할**
   - 문제를 두 개의 작은 부분 문제로 나눔

3. **정복**
   - 부분 문제 1의 해를 구함
   - 부분 문제 2의 해를 구함

4. **결합**
   - 부분 문제들의 해를 합쳐서 전체 문제의 해를 도출

### 분할 정복 기법의 예시

#### 1) 가짜 동전 찾기
- n개의 동전들 중에 가짜 동전이 하나 포함되어 있다.
- 가짜 동전은 진짜 동전에 비해 아주 조금 가볍다.
- 진짜 동전들의 무게가 동일하다고 할 때, **양팔 저울**을 이용해서 가짜 동전을 찾아보자.

- **조건**
  - 양팔 저울을 **최소로 사용**해서 가짜 동전을 찾는 방법은 무엇인가?

- **예시**
  - 동전이 24개 있을 때 (진짜 23개, 가짜 1개), 어떻게 가짜를 찾을 수 있을까?

- **설명**
  - 1. **분할 (Divide)**
    - 전체 동전을 가능한 한 균등하게 2개 또는 3개의 그룹으로 나눈다.
    - 양팔 저울에 두 그룹을 올려 무게를 비교한다.

  - 2. **정복 (Conquer)**
    - 만약 두 그룹의 무게가 같다면 → 가짜 동전은 **남은 그룹**에 있다.
    - 만약 한쪽이 가볍다면 → 가짜 동전은 **가벼운 그룹**에 있다.
    - 이렇게 하면 매번 확인해야 할 동전의 개수가 줄어든다.

  - 3. **결합 (Combine)**
    - 남은 그룹을 다시 같은 방식으로 분할하여 반복한다.
    - 결국 하나의 동전만 남게 되고, 그 동전이 가짜 동전임을 알 수 있다.

#### 2) 거듭제곱

- **문제**: 자연수 C의 n 제곱 값을 구하는 함수 구현
- 단순 반복문으로 계산하면 O(n) 시간이 걸리지만,  
  **분할 정복 기법(Exponentiation by Squaring)** 을 사용하면 O(log n) 시간에 해결할 수 있다.

- 아이디어
  1. n이 짝수일 경우:   
      - C<sup>n</sup> = [ C<sup>n/2</sup> X C<sup>n/2</sup> ]
  2. n이 홀수일 경우:   
      - C<sup>n</sup> = [ C<sup>(n-1)/2</sup> X C<sup>(n-1)/2</sup> X C ]

  3. n = 0일 경우:
      - C<sup>0</sup> = 1


- 코드 구현 (Python)
  ```python
  def power(c, n):
      # base case
      if n == 0:
          return 1
      if n == 1:
          return c
      
      # 분할 정복
      half = power(c, n // 2)
      
      if n % 2 == 0:  # n이 짝수
          return half * half
      else:           # n이 홀수
          return half * half * c


  # 테스트
  print(power(2, 10))  # 1024
  print(power(3, 5))   # 243
  print(power(5, 0))   # 1
  ```


--- 

## 병합 정렬

여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식

### 병합 정렬 과정
- 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
- `top-down` 방식
- 시간 복잡도 : `O(n log n)`

### 병합 정렬 과정 예시

**문제** : {69, 10, 30, 2, 16, 8, 31, 22}를 병합정렬

1. 분할 단계 (Divide)
    - 전체 배열을 **절반으로 쪼갬**
    - 더 이상 쪼갤 수 없을 때까지 나눔 (즉, 원소가 1개 단위가 될 때까지)

2. 정복 단계 (Conquer: 병합 & 정렬)
    - 이제 **두 개씩 묶어서 정렬하며 합침**
    - 합칠 때 **작은 값이 앞으로** 오도록 비교하면서 병합

3. 재병합
    - 이제 다시 두 묶음을 합치며 정렬

4. 최종 병합
    - 마지막으로 두 부분 배열을 합쳐 최종 정렬된 배열을 얻음

```python
def merge_sort(arr):
    # 원소가 1개 이하이면 그대로 반환
    if len(arr) <= 1:
        return arr
    
    # 1. 분할 (Divide)
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])   # 왼쪽 반
    right = merge_sort(arr[mid:])  # 오른쪽 반
    
    # 2. 정복 (Conquer: 병합 과정)
    return merge(left, right)


def merge(left, right):
    result = []
    i = j = 0
    
    # 두 배열 비교하면서 작은 값부터 넣기
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # 남은 요소들 추가
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

```

---

## 퀵 정렬

기준값을 중심으로 주어진 배열을 두 개로 분할하고, 각각을 정렬하여 전체 배열을 정렬하는 방식

# 병합 정렬 vs 퀵 정렬 비교

| 구분        | 병합 정렬 (Merge Sort)                       | 퀵 정렬 (Quick Sort)                                  |
|-------------|----------------------------------------------|------------------------------------------------------|
| **분할 기준** | 배열을 단순히 반으로 나눔                     | 기준 원소(pivot)를 정하고, 작은 값은 왼쪽 큰 값은 오른쪽 |
| **병합 처리** | 분할한 뒤 다시 합칠 때 병합 과정 필요           | 분할하면서 이미 정리되므로 별도의 병합 과정 불필요        |
| **시간 복잡도** | 항상 O(n log n)                              | 평균 O(n log n), 최악의 경우 O(n²)                   |
| **안정성**    | 안정 정렬(같은 값의 순서가 유지됨)              | 불안정 정렬(같은 값의 순서가 바뀔 수 있음)             |
| **특징**     | 성능이 일정하고 안정적, 데이터 크기와 상관없이 동일 | 평균적으로 가장 빠름, 하지만 pivot 선택에 따라 성능 차이 |

### Partitioning (파티셔닝)

- 퀵 정렬에서 핵심이 되는 단계
- 배열에서 **Pivot(기준 값)**을 하나 정한 뒤, 기준 값보다 작은 원소는 왼쪽, 큰 원소는 오른쪽에 배치

### Partitioning 과정

1. 작업 영역 지정
    - 현재 정렬해야 할 구간을 정한다.

2. Pivot 결정
    - 보통 배열의 맨 왼쪽 원소를 Pivot으로 설정  
    - (중간 값, 오른쪽 값 등 다른 방식도 가능하지만 여기서는 **왼쪽 끝 값**을 기준으로 사용)

3. Pivot 기준으로 배치 변경
    - Pivot보다 작은 값 → 왼쪽
    - Pivot보다 큰 값 → 오른쪽
    - 이때 Pivot은 최종적으로 올바른 위치에 고정됨(FIX)


### Partitioning 반복
- 한 번의 파티셔닝이 끝나면, Pivot은 제자리를 찾게 된다.
- 이제 Pivot을 제외한 **왼쪽 구간**과 **오른쪽 구간**에 대해 같은 과정을 재귀적으로 반복한다.
- 구간의 크기가 1이 되면 더 이상 정렬할 필요가 없다.


### 특징
- Partitioning을 반복하면서 전체 배열이 점점 정렬된 상태가 된다.
- 별도의 **병합 과정이 필요 없음** (퀵 정렬의 장점)
- Pivot 선택에 따라 성능 차이가 큼 (잘못 선택하면 최악의 경우 O(n²))


```python
def quick_sort(arr):
    # 원소가 1개 이하라면 이미 정렬된 상태
    if len(arr) <= 1:
        return arr
    
    pivot = arr[0]  # 첫 번째 원소를 pivot으로 선택
    left = [x for x in arr[1:] if x <= pivot]   # pivot보다 작은 값들
    right = [x for x in arr[1:] if x > pivot]   # pivot보다 큰 값들
    
    # 재귀적으로 정렬 후 합치기
    return quick_sort(left) + [pivot] + quick_sort(right)


# 실행 예시
arr = [6, 9, 5, 1, 3, 13, 10]
print(arr)                # [6, 9, 5, 1, 3, 13, 10]
print(quick_sort(arr))    # [1, 3, 5, 6, 9, 10, 13]
```

### Hoare Partition

퀵 정렬에서 배열을 분할하는 방식 중 하나

- 기준 값(Pivot)을 배열의 첫 번째 원소로 선택
- **양쪽 끝에서 시작하는 두 개의 포인터(i, j)** 를 이용해 원소들을 교환하면서 Pivot 기준으로 배열을 나눔

- 특징
    - 양쪽에서 포인터가 이동하면서 잘못 위치한 원소를 서로 바꿔줌
    - Pivot 기준으로 왼쪽은 작은 값, 오른쪽은 큰 값으로 나뉨
    - 다른 방식(Lomuto Partition)보다 교환 횟수가 적고 효율적
```python
def hoare_partition(arr, l, r):
    p = arr[l]   # Pivot = 첫 번째 원소
    i, j = l, r

    while i <= j:
        while i <= j and arr[i] <= p:
            i += 1
        while i <= j and arr[j] >= p:
            j -= 1
        if i < j:
            arr[i], arr[j] = arr[j], arr[i]

    # Pivot과 arr[j] 교환 → Pivot을 제자리로 이동
    arr[l], arr[j] = arr[j], arr[l]

    return j



# 실행 예시
arr = [6, 9, 5, 1, 3, 13, 10]
pos = partition(arr, 0, len(arr) - 1)
print("Partition 결과:", arr)     # [3, 1, 5, 6, 9, 13, 10]
print("Pivot 최종 위치:", pos)     # 3
```

### Lomuto Partition

- Pivot: **배열의 마지막 원소**를 기준으로 삼음
- 배열을 pivot보다 작은 값 / 큰 값 두 그룹으로 나누는 과정
- 인덱스 `i`를 이용해서 "pivot보다 작은 값들이 어디까지 모여 있는지" 관리함
- 특징
    - 구현이 단순해서 교과서적으로 많이 쓰임
    - pivot을 마지막 원소로 고정하기 때문에 직관적
    - 하지만 교환 횟수가 많음 (모든 작은 원소를 매번 swap)
    - 반면, Hoare Partition은 교환 횟수는 적지만 구현이 조금 더 복잡

```python
def lomuto_partition(arr, p, r):
    x = arr[r]      # pivot: 마지막 원소
    i = p - 1       # i는 pivot보다 작은 값들의 마지막 인덱스

    for j in range(p, r):  # p ~ r-1까지 순회
        if arr[j] <= x:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]  # 작은 값은 앞으로 보냄

    # pivot을 제자리로 이동
    arr[i + 1], arr[r] = arr[r], arr[i + 1]
    return i + 1

arr = [6, 9, 5, 1, 3, 13, 10]
pos = lomuto_partition(arr, 0, len(arr) - 1)
print("Partition 결과:", arr)   # [6, 5, 1, 3, 9, 10, 13]
print("Pivot 최종 위치:", pos)   # 4
```

### Lomuto Partition vs Hoare Partition 비교

| 구분            | Lomuto Partition                     | Hoare Partition                         |
|-----------------|--------------------------------------|------------------------------------------|
| **Pivot 선택**   | 보통 **마지막 원소**                 | 보통 **첫 번째 원소**                    |
| **포인터 구조**  | 단일 포인터 `i` 사용                 | 양쪽 포인터 `i`, `j` 사용                |
| **구현 난이도**  | 단순, 코드가 직관적                  | 상대적으로 복잡                          |
| **교환 횟수**    | 상대적으로 많음 (작은 원소마다 swap) | 적음, 효율적                             |
| **실무 활용**    | 교과서 예시, 학습용으로 자주 사용    | 실제 라이브러리 구현에 더 가까움         |


## 이진 검색

자료의 가운데에 있는 항목의 키 값과 비교하여   
다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법

> 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써    
> 검색범위를 반으로 줄여가면서 보다 빠르게 검색 수행 가능

### 이진 검색의 과정

1. 기본 개념
- 정렬된 배열에서 원하는 값을 빠르게 찾는 알고리즘
- 탐색 범위를 절반씩 줄여나가기 때문에 **시간 복잡도: O(log n)**

2. 동작 과정
    1) 자료의 **중앙에 있는 원소**를 고른다.
    2) 중앙 원소의 값과 **찾고자 하는 목표 값**을 비교한다.
    3) 비교 결과에 따라 탐색 범위를 줄인다.
        - 목표 값 < 중앙 원소 → **왼쪽 절반**에서 검색
        - 목표 값 > 중앙 원소 → **오른쪽 절반**에서 검색
    4) 목표 값을 찾을 때까지 ①~③ 과정을 반복한다.


3. 특징
- 이진 검색을 하기 위해서는 **<u>자료가 반드시 정렬된 상태</u>** 여야 한다.
- 시간 복잡도: `O(log n)`
- 공간 복잡도: `O(1)`
```python
def binary_search(arr, key):
    low, high = 0, len(arr) - 1

    while low <= high:
        mid = (low + high) // 2   # 중앙 인덱스

        if arr[mid] == key:
            return mid
        elif arr[mid] > key:
            high = mid - 1
        else:
            low = mid + 1

    return -1  # 찾지 못한 경우


  arr = [2, 4, 7, 9, 11, 19, 23]

print(binary_search(arr, 9))   # 3 (인덱스)
print(binary_search(arr, 19))  # 5
print(binary_search(arr, 8))   # -1 (없음)
```


---



# 분할 정복 알고리즘 정리

## 1. 병합 정렬 (Merge Sort)
- 외부 정렬(External Sort)의 기본이 되는 정렬 알고리즘
- 멀티코어(Multi-Core) CPU나 다수의 프로세서에서 정렬 알고리즘을 병렬화하기 위해 활용됨


## 2. 퀵 정렬 (Quick Sort)
- 매우 큰 입력 데이터에 대해 좋은 성능을 보이는 정렬 알고리즘


## 3. 이진 검색 (Binary Search)
- 정렬된 데이터를 기준으로 특정 값이나 범위를 검색하는 데 사용
- 심화 학습 키워드: **Lower Bound, Upper Bound**
  - 정렬된 배열에서 특정 값 이상(이하)이 처음으로 나타나는 위치를 찾는 알고리즘
  - 특정 데이터의 범위 검색 등에 활용
