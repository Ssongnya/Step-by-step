# 병합 정렬

## 병합 정렬의 특징

### 연결 리스트를 이용한 병합 정렬

#### 병합 정렬
여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식

1) 분할 정복 알고리즘 활용
- **자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄**
- Top-Down 방식

2) 시간 복잡도

- **O(n log n)**

## 병합 정렬의 과정

### {69, 10, 30, 2, 16, 8, 31, 22}를 병합 정렬하는 과정

#### 분할 단계
전체 자료 집합에 대하여, 최소 크기의 부분집합이 될 때까지 분할 작업을 계속함

[69, 10, 30, 2, 16, 8, 31, 22]   
→ [69, 10, 30, 2], [16, 8, 31, 22]   
→ [69, 10], [30, 2], [16, 8], [31, 22]   
→ [69], [10], [30], [2], [16], [8], [31], [22]

#### 병합 단계

2개의 부분집합을 정렬하면서 하나의 집합으로 병합   
8개의 부분집합이 1개로 병합될 때까지 반복함

[69], [10], [30], [2], [16], [8], [31], [22]
→ [10, 69], [2, 30], [8, 16], [22, 31]
→ [2, 10, 30, 69], [8, 16, 22, 31]
→ [2, 8, 10, 16, 22, 30, 31, 69]

## 병합 정렬 알고리즘

### 분할 과정의 알고리즘

```python
def merge_sort(m):
    if len(m) <= 1:  # 사이즈가 0이거나 1인 경우, 바로 리턴
        return m

    # 1. DIVIDE 부분
    mid = len(m) // 2
    left = m[:mid]
    right = m[mid:]

    # 2. 리스트의 크기가 1이 될 때까지 merge_sort 재귀 호출
    left = merge_sort(left)
    right = merge_sort(right)

    # 3. CONQUER 부분 : 분할된 리스트들 병합
    return merge(left, right)
```

### 병합 과정

```python
def merge(left, right):
    result = []    # 두 개의 분할된 리스트를 병합하여 result를 만듦

    while len(left) > 0 and len(right) > 0 
    """
    양쪽 리스트에 원소가 남아있는 경우
    두 서브 리스트의 첫 원소들을 비교하여 작은 것 부터 result에 추가함
    """
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    
    if len(left) > 0:    # 왼쪽 리스트에 원소가 남아있는 경우
        result.extend(left)
    
    if len(right) > 0:   # 오른쪽 리스트에 원소가 남아있는 경우
        result.extend(right)
    return result
```

| |삽입 정렬|병합 정렬|
|-|---------|--------|
|평균 수행시간|O(n<sup>2</sup>)|O(n log n)|
|최악 수행시간|O(n<sup>2</sup>)|O(n log n)|
|알고리즘 기법|비교와 교환|분할 정복|
|비고|n의 개수가 작을 때 효과적임|연결 List의 경우 가장 효율적인 방식|