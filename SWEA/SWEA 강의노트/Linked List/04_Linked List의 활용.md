# List의 활용

## List를 이용한 Stack

### 스택의 원소 : 리스트의 노드
- 스택 내의 순서는 리스트의 링크를 통해 연결됨
- Push : 리스트의 마지막에 노드 삽입
- Pop : 리스트의 마지막 노드 반환/삭제

### 변수 Top
- 리스트의 마지막 노드를 가리키는 변수
- 초기 상태: `Top = None`

## List를 이용한 Stack의 연산

### 리스트를 이용해 Push와 Pop 연산 구현

1) None 값을 가지는 노드를 만들어 스택 초기화
2) 원소 A 삽입 : Push(A)
3) 원소 B 삽입 : Push(B)
4) 원소 C 삽입 : Push(C)
5) 원소 반환 : Pop

### Push/Pop 연산의 알고리즘

```python
def push(i):    # 원소 i를 스택 top(맨앞) 위치에 push
    global top
    top = Node(i, top)  # 새로운 노드 생성

def pop():      # 스택의 top을 pop
    global top

    if top == None:   # 빈 리스트이면
        print("error")
    else:
        data = top.data
        top = top.link      # top이 가리키는 노드를 바꿈
        return data
```
---

## 우선 순위 Queue

### 우선순위 큐의 구현과 기본 연산

- 우선순위 큐의 구현 
    - 연결 리스트를 이용한 우선순위 큐

- 우선순위 큐의 기본 연산
    - 삽입 : enQueue
    - 삭제 : deQueue

### 순차 리스트를 이용한 우선순위 큐 구현

- 순차 리스트를 이용하여 자료 저장
- 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
- 가장 앞에 최고 우선순위의 원소가 위치하게 됨

#### 문제점

**배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생하게 되면서, 이에 소요되는 시간이나 메모리 낭비가 크다**

### 리스트를 이용한 우선순위 Queue 구현

- 연결 리스트를 이용하여 자료 저장
- 원소를 삽입하는 과정에서 리스트 내 노드의 원소들과 비교하여 적절한 위치에 노드를 삽입하는 구조
- 리스트의 가장 앞쪽에 최고 우선순위가 위치하게 됨

#### 배열 대비 장점

삽입/삭제 연산 이후 원소의 재배치가 필요 없어서, 메모리의 효율적인 사용이 가능하다.