# Binary Tree

## Binary Tree의 특징

### 이진 트리

1. 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리
2. 노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리   
   각각 다음과 같이 불림:
    - 왼쪽 자식 노드
    - 오른쪽 자식 노드
3. 이진 트리의 예
```
A     A   A           A
     /     \        /   \
   B        B      B     C
                       /   \
                      D     E

```
4. 레벨 i 에서의 노드의 최대 개수는 2<sup>i</sup>
5. 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h + 1)개, 최대 개수는 (2<sup>h+1</sup> - 1)개가 됨   
    ex) 트리의 높이가 3이라면, 노드의 최소 개수는 **3** + 1 = 4개     
        노드의 최대 개수는 2<sup>**3** + 1</sup> - 1 = 15

## Binary Tree의 종류

1. 포화 이진 트리(Full binary Tree)
2. 완전 이진 트리(Complete binary Tree)
3. 편향 이진 트리(Skewed binary Tree)

### 포화 이진 트리

모든 레벨에 노드가 포화상태로 차 있는 이진 트리

1) 최대 노드 개수인 (2<sup>h+1</sup> - 1)의 노드를 가진 이진트리
    - 예) 높이가 3일 때 : 2<sup>**3** + 1</sup> - 1 = 15개의 노드

2) 루트를 1번으로 하여 2<sup>h + 1</sup> - 1 까지 정해진 위치에 대한 노드의 번호를 가짐

```
                   1
          /                  \  
        2                      3
    /       \              /        \
  4          5           6            7        
 /  \      /   \       /   \        /   \
8    9    10    11    12    13     14    15
```

### 완전 이진 트리

높이가 h이고 노드 수가 n개일 때 Full 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리
(단, 2<sup>h</sup> ≤ n ≤ 2<sup>h + 1</sup> - 1)

ex) 노드가 10개인 완전 이진 트리
```
                   1
          /                  \  
        2                      3
    /       \              /        \
  4          5           6            7        
 /  \      / 
8    9    10
```

### 편향 이진 트리

높이 h에 대한 최소 개수의 노드를 가지면서 한 쪽 방향의 자식 노드 만을 가진 이진 트리

#### 왼쪽 편향 이진 트리
```
            1
          /
        2
      /
    3
  /
4
```

#### 오른쪽 편향 이진 트리
```
1
  \
    2
      \
        3
          \ 
            4
```

## 이진트리의 순회

### 순회

트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말하는데, 트리는 비선형구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수 없음
-> **특별한 방법이 필요!!**

### 3가지의 기본적인 순회방법
```
        V (루트)
    /       \
  L           R
(왼쪽서브트리) (오른쪽 서브트리)
```

1. 전위 순회

    - **V → L → R**
    - 자손노드보다 루트노드를 먼저 방문

2. 중위 순회

    - **L → V → R**
    - 왼쪽 자손, 루트, 오른쪽 자손 순으로 방문

3. 후위 순회

    - **L → R → V**
    - 루트노드보다 자손을 먼저 방문

### 전위 순회

- 수행 방법
  - 1) 현재 노드 n을 방문하여 처리 : V
  - 2) 현재 노드 n의 왼쪽 서브트리로 이동 : L
  - 3) 현재 노드 n의 오른쪽 서브트리로 이동 : R
  ```python
  def preorder_traverse(T):   # 전위순회
    if T:
      visit(T)
      preorder_traverse(T.left)
      preorder_traverse(T.right)
  ```

#### 전위 순회 트리
```
         A
     /      \
    B        C
  /   \    /   \
  D    E   F    G
     /   \
    H     I
```
> T0 : A가 root인 트리   
> T1 : B가 root인 트리   
> T2 : C가 root인 트리   
> T3 : E가 root인 트리

순서_1 : T0 → T1 → T2   
순서_2 : A → B, D(T3) → C, F, G   
<u>총 순서 : A → B → D → E → H → I → C → F → G</u>

### 중위 순회

- 수행 방법
  - 1) 현재 노드 n의 왼쪽 서브트리로 이동 : L
  - 2) 현재 노드 n을 방문하여 처리 : V
  - 3) 현재 노드 n의 오른쪽 서브트리로 이동 : R
  ```python
  def inorder_traverse(T): # 중위순회
    if T:
      inorder_traverse(T.left)
      visit(T)
      inorder_traverse(T.right)
  ```

#### 중위 순회 트리
```
         A
     /      \
    B        C
  /   \    /   \
  D    E   F    G
     /   \
    H     I
```
> T0 : A가 root인 트리   
> T1 : B가 root인 트리   
> T2 : C가 root인 트리   
> T3 : E가 root인 트리

순서_1 : T1 → T0 → T2   
**순서_2 : D, B(T3) → A → F, C, G**   
<u>총 순서 : D → B → H → E → I → A → F → C → G</u>

### 후위 순회

- 수행 방법
  - 1) 현재 노드 n의 왼쪽 서브트리로 이동 : L
  - 2) 현재 노드 n의 오른쪽 서브트리로 이동 : R
  - 3) 현재 노드 n을 방문하여 처리 : V
  ```python
  def postorder_traverse(T): # 중위순회
    if T:
      postorder_traverse(T.left)
      postorder_traverse(T.right)
      visit(T)
  ```

#### 후위 순회 트리
```
         A
     /      \
    B        C
  /   \    /   \
  D    E   F    G
     /   \
    H     I
```
> T0 : A가 root인 트리   
> T1 : B가 root인 트리   
> T2 : C가 root인 트리   
> T3 : E가 root인 트리

순서_1 : T1 → T2 → T0   
**순서_2 : D(T3), B → F, G, C → A**   
<u>총 순서 : D → H → I → E → B → F → G → C → A</u>


### 이진 트리 순회방법 비교

1. 프리오더 전위 순회
2. 인오더 중위 순회
3. 포스트오더 후위 순회

| 순회 방식 | 방문 순서         | 예시 결과       |
| ----- | ------------- | ----------- |
| 프리오더  | 루트 → 왼쪽 → 오른쪽 | A B D E C F |
| 인오더   | 왼쪽 → 루트 → 오른쪽 | D B E A C F |
| 포스트오더 | 왼쪽 → 오른쪽 → 루트 | D E B F C A |
