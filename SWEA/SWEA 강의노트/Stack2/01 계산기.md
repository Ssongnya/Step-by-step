# 계산기

## 계산기에서 Stack의 활용

- `A * B - C / D`
- `(6 + 5 * (2 - 8)/2)`

-> 이와 같은 문자열 계산식은 '스택을 이용하여 결과값을 계산할 수 있다.'

### 문자열 수식 계산의 일반적 방법

1. 중위표기법의 수식을 후위표기법으로 변경
    - 스택 이용
    - 중위표기법 : 연산자를 피연산자의 가운데 표기하는 방법
        - ex) `A + B`

2. 후위표기법으로 변경된 수식을 스택을 이용하여 계산
    - 후위표기법 : 연산자를 피연산자 뒤에 표기하는 방법
        - ex) `AB+`

## 중위표기식을 후위표기식으로 변환

### Step1. 중위표기식의 후위표기식으로 변환하는 방법_1

1) 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현
2) 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동
3) 괄호 제거

#### 예시) `A * B - C / D` 변환 방법

1단계 : `((A*B) - (C/D))`   
2단계 : `((A B) * (C D) /) -`   
3단계 : `AB*CD/-`   

- <u>문제점</u> : **사람이 손으로 처리하기는 쉽지만** 프로그램으로 작성하기는 어려움!
- <u>Solution</u> : 중위표기식을 **후위표기식으로 변환하는 알고리즘** 개발

### Step1. 중위표기식 → 후위표기식 변환 방법_2 (스택 이용)

중위표기법에서 후위표기법으로 **변환 알고리즘**

1. 입력 받은 중위표기식에서 토큰을 읽음
2. 토큰이 피연산자이면 토큰을 출력
3. 토큰이 연산자(괄호포함)일 경우
    - 토큰이 stack의 top에 저장되어 있는 연산자보다 우선순위가 높으면 
        → 스택에 push
    - 우선순위가 높지 않다면 
        → 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 스택에서 pop한 후 토큰의 연산자를 push한다.
    - 만약 top에 연산자가 없으면 → push
4. 토큰이 오른쪽 괄호 ')'일 경우
    - 스택 top에 왼쪽 괄호 '('가 올 때까지 스택에 pop 연산을 수행
    - pop한 연산자를 출력
    - 왼쪽 괄호를 만나면 pop만 하고 출력하지는 않음
 5. 중위표기식에 더 읽을 것이 없다면 중지, 더 읽을 것이 있다면 1부터 반복
 6. 스택에 남아 있는 연산자들 모두 pop하여 출력
    - 스택 밖의 왼쪽 괄호는 우선 순위가 가장 높으며, 스택 안의 왼쪽 괄호는 우선 순위가 가장 낮음.

#### 예시) 중위표기법으로 표현된 수식

-> 변환알고리즘을 사용한 `(6 + 5 * (2 - 8)/2)` 단계별 예시

1️⃣ ISP( In-Stack Priority )와 ICP( Incoming Priority ) 개념
변환 알고리즘에서 연산자 스택을 사용할 때, 
현재 스택 안에 있는 연산자와 새로 읽은 연산자의 우선순위를 비교해야 한다.
이때 두 가지 우선순위 기준이 존재함.

| 용어                          | 의미                 | 비교 대상      |
| --------------------------- | ------------------ | ---------- |
| **ISP (In-Stack Priority)** | 스택 안에 있는 연산자의 우선순위 | 스택 내부의 연산자 |
| **ICP (Incoming Priority)** | 새로 들어오려는 연산자의 우선순위 | 방금 읽은 연산자  |


👉 규칙:

**ICP > ISP** → 새 연산자를 스택에 push
**ICP ≤ ISP** → 스택에서 pop 후 출력 (그리고 다시 비교)

이 방식으로 연산자들의 우선순위를 유지한다.

2️⃣ 연산자 우선순위 표 (예시)
연산자 우선순위는 ISP와 ICP에서 다르게 설정된다.
특히 여는 괄호 `'('`는 특별 취급된다.

| 연산자        | ISP | ICP | 이유                          |
| ---------- | --- | --- | --------------------------- |
| `(`        | 0   | 5   | 새로 들어올 때는 가장 높은 우선순위 (push) |
| `)`        | -   | -   | pop 조건으로만 사용                |
| `+` `-`    | 2   | 2   | 동일                          |
| `*` `/`    | 4   | 4   | 동일                          |
| 피연산자       | -   | -   | 그냥 출력                       |
| 스택의 바닥 `#` | 0   | 0   | 비교 기준용                      |

3️⃣ 예제: `(6 + 5 * (2 - 8) / 2)`
중위 표기 → 후위 표기 변환 과정

초기 상태:
```
출력: (빈 상태)
스택: ['#']
```

단계별 변환 (ISP, ICP 비교)

`(` 읽음

ICP(`(`)=5, ISP(`#`)=0 → push


```
출력: 
스택: ['#', (]
```

`6` 읽음 (피연산자 → 바로 출력)


```출력: 6
스택: ['#', (]
```

`+` 읽음

ICP(+)=2, ISP(()=0 → push


```출력: 6
스택: ['#', (, +]
```

`5` 읽음


```출력: 6 5
스택: ['#', (, +]
```

`*` 읽음

ICP(*)=4, ISP(+)=2 → push


```출력: 6 5
스택: ['#', (, +, *]
```
`(` 읽음

ICP(()=5, ISP(*)=4 → push


```출력: 6 5
스택: ['#', (, +, *, (]
```
`2` 읽음


```출력: 6 5 2
스택: ['#', (, +, *, (]
```
`-` 읽음

ICP(-)=2, ISP(()=0 → push


```출력: 6 5 2
스택: ['#', (, +, *, (, -]
```
`8` 읽음


```출력: 6 5 2 8
스택: ['#', (, +, *, (, -]
```
`)` 읽음

스택에서 '(' 나올 때까지 pop


```pop → 출력: 6 5 2 8 -
스택: ['#', (, +, *]
```
`/` 읽음

ICP(/)=4, ISP(*)=4 → ICP ≤ ISP → pop


```pop → 출력: 6 5 2 8 - *
스택: ['#', (, +]
```
다시 비교: ICP(/)=4, ISP(+)=2 → push


```스택: ['#', (, +, /]
```
`2` 읽음


```출력: 6 5 2 8 - * 2
스택: ['#', (, +, /]
```
`)` 읽음

'(' 나올 때까지 pop


```pop → 출력: 6 5 2 8 - * 2 /
pop → 출력: 6 5 2 8 - * 2 / +
스택: ['#']
```
스택 비우기
```출력: 6 5 2 8 - * 2 / +```

✅ 최종 후위 표기:

`6 5 2 8 - * 2 / +`

## 후위표기법 수식을 스택을 계산

### Step2. 후위표기법의 수식을 스택을 이용하여 계산

1) 피연산자를 만나면 스택에 push함
2) 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산결과를 다시 스택에 push함
3) 수식이 끝나면, 마지막으로 스택을 pop하여 출력

> <u>계산 시 주의 사항!</u>   
> 후위표기식을 계산 시, **<u>피연산자를 스택에 쌓아 계산!</u>**

#### 예시) 후위표기법 수식을 스택으로 계산

-> `6528-*2/+` 단계별 예시
| 읽은 토큰 | 동작                                       | 스택 상태         | 출력/계산          |
| ----- | ---------------------------------------- | ------------- | -------------- |
| `6`   | 피연산자 → push                              | \[6]          |                |
| `5`   | 피연산자 → push                              | \[6, 5]       |                |
| `2`   | 피연산자 → push                              | \[6, 5, 2]    |                |
| `8`   | 피연산자 → push                              | \[6, 5, 2, 8] |                |
| `-`   | 연산자 → pop 8, 2 → 2 - 8 = -6 → push       | \[6, 5, -6]   | 2 - 8 = -6     |
| `*`   | 연산자 → pop -6, 5 → 5 \* -6 = -30 → push   | \[6, -30]     | 5 \* -6 = -30  |
| `2`   | 피연산자 → push                              | \[6, -30, 2]  |                |
| `/`   | 연산자 → pop 2, -30 → -30 / 2 = -15 → push  | \[6, -15]     | -30 / 2 = -15  |
| `+`   | 연산자 → pop -15, 6 → 6 + (-15) = -9 → push | \[-9]         | 6 + (-15) = -9 |


### 파이썬 코드 예제
```python
def evaluate_postfix(expression):
    stack = []
    for token in expression.split():
        if token.isdigit() or (token[0] == '-' and token[1:].isdigit()):
            stack.append(int(token))  # 피연산자 push
        else:
            b = stack.pop()  # 두 번째 피연산자
            a = stack.pop()  # 첫 번째 피연산자
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            elif token == '/':
                stack.append(int(a / b))  # 정수 나눗셈
    return stack[0]

# 테스트
postfix_expr = "6 5 2 8 - * 2 / +"
print(evaluate_postfix(postfix_expr))  # 출력: -9
```

## 수식을 `eval()` 내장 함수로 계산

### 문자열로 된 수식을 계산 시
> 스택을 두 번 사용해서 처리했던 연산을   
> 파이썬에서 제공되는 **`eval()` 내장 함수**로 계산할 수 있음.

#### `eval()` 수식
- 문자열로 된 수식을 계산함
- Evaluation = "값을 구함"이란 뜻
- 올바른 수식이 아닌 경우 SyntaxError 예외가 발생함
- `eval("6+5*(2-8)/2")`는 문자열로 된 수식의 계산결과를 반환함