# 분할정복

## 분할 정복 알고리즘

### 설계 전략

1. 분할 - 해결할 문제를 **여러 개의 작은 부분**으로 나눔
2. 정복 - 나눈 작은 문제를 **각각 해결**
3. 통합 - (필요하다면) 해결된 **해답을 모음**

### 거듭 제곱 알고리즘 : O(n)

```python
def Power(Base, Exponent):
    if Base == 0 : return 1
    result = 1  # Base^0은 1이므로
    for i in range(Exponent):
        result *= Base
    return result

print(power(2, 10))  # 1024
```
동작: 2를 10번 곱함
시간복잡도: O(n)

### 분할 정복 기반의 알고리즘 : O(log<sub>2</sub>n)
```python
def Power(Base, Exponent):
    if Exponent == 0 or Base == 0 : # 0승이면 1
        return 1

    if Exponent % 2 == 0 :          # 짝수인 경우
        NewBase = Power(Base, Exponent/2)
        return NewBase * NewBase
    
    else :                          # 홀수인 경우
        NewBase = Power(Base, (Exponent-1)/2)
        return (NewBase * NewBase) * Base
```

#### 실행 과정 (2<sup>10</sup>)
```sql
power(2, 10)
 → half = power(2, 5)
      → half = power(2, 2)
            → half = power(2, 1)
                 → half = power(2, 0) → 1
            → 1 * 1 * 2 = 2
      → 2 * 2 * 2 = 8
 → 8 * 8 = 64 (짝수 단계 계산)
 → 64 * 2 * 2 (마지막 합성) = 1024
```
장점: 반복문보다 빠르게 계산 가능
시간복잡도: `O(log n)`

## 퀵 정렬 

분할 정복의 대표적인 예시 중 하나는 퀵 정렬이다.

### 퀵 정렬과 합병 정렬의 비교

||합병정렬|퀵 정렬|
|-|-------|------|
|공통점|주어진 리스트를 두 개로 분할하고, 각각을 정렬|주어진 리스트를 두 개로 분할하고, 각각을 정렬|
|차이점|분할할 때, 단순하게 두 부분으로 나눔|분할할 때, 기준 아이템(Pivot item)을 중심으로, 이보다 **작은 것은 왼편, 큰 것은 오른편**에 위치 시킴|
||각 부분 정렬이 끝난 후, **'합병'이란 후처리 작업이 필요함**|각 부분 정렬이 끝난 후, **후처리 작업이 필요로 하지 않음**|

| 구분       | 합병 정렬      | 퀵 정렬                               |
| -------- | ---------- | ---------------------------------- |
| 분할 방법    | 단순 반으로 분할  | 피봇(Pivot)을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽 |
| 후처리      | 병합 필요      | 병합 불필요                             |
| 평균 시간복잡도 | O(n log n) | O(n log n)                         |
| 최악 시간복잡도 | O(n log n) | O(n²)                              |

### 퀵 정렬 알고리즘
```python
def quickSort(a, begin, end):
    if begin < end:
        p = partition(a, begin, end)   # 피봇을 기준으로 분할
        quickSort(a, begin, p-1)       # 왼쪽 부분 정렬
        quickSort(a, p+1, end)         # 오른쪽 부분 정렬
```

### 주어진 리스트에서 피봇을 구하는 알고리즘
```python
def partition(a, begin, end):
    pivot = (begin + end) // 2  # 피봇을 배열의 중간 인덱스로 선택
    L = begin                  # 왼쪽 포인터
    R = end                    # 오른쪽 포인터

    # L과 R이 교차할 때까지 반복
    while L < R:
        # 1) 왼쪽에서 피봇보다 큰 값을 찾을 때까지 이동
        while a[L] < a[pivot] and L < R:
            L += 1

        # 2) 오른쪽에서 피봇보다 작은 값을 찾을 때까지 이동
        while a[R] >= a[pivot] and L < R:
            R -= 1

        # 3) L < R이면 두 값을 교환
        if L < R:
            # 만약 L이 피봇 위치라면, 피봇 위치를 R로 갱신해야 함
            if L == pivot:
                pivot = R
            # L과 R의 값을 교환
            a[L], a[R] = a[R], a[L]

    # while문 종료 후: L과 R이 만남 → 피봇과 R을 교환하여 피봇을 제자리에 둠
    a[pivot], a[R] = a[R], a[pivot]

    return R  # 피봇의 최종 위치 반환


def quickSort(a, begin, end):
    """퀵 정렬 메인 함수"""
    if begin < end:  # 정렬할 구간이 남아있다면
        p = partition(a, begin, end)  # 피봇 기준으로 분할
        quickSort(a, begin, p - 1)    # 피봇 왼쪽 부분 정렬
        quickSort(a, p + 1, end)      # 피봇 오른쪽 부분 정렬


# 실행 예제
arr = [68, 11, 29, 3, 15, 9, 32, 23]
print("정렬 전:", arr)  # 정렬 전: [68, 11, 29, 3, 15, 9, 32, 23]

quickSort(arr, 0, len(arr) - 1)

print("정렬 후:", arr)  # 정렬 후 : 정렬 후: [3, 9, 11, 15, 23, 29, 32, 68]

```
### `partition` 단계별 추적
| 단계 | L | R | pivot | 배열 상태                           | 동작 설명                         |
| -- | - | - | ----- | ------------------------------- | ----------------------------- |
| 1  | 0 | 7 | 3     | \[68, 11, 29, 3, 15, 9, 32, 23] | 초기 상태                         |
| 2  | 0 | 7 | 3     | \[68, 11, 29, 3, 15, 9, 32, 23] | L: 68 < 3? ❌ → 이동 안 함         |
| 3  | 0 | 6 | 3     | \[68, 11, 29, 3, 15, 9, 32, 23] | R: 23 >= 3 → R=6              |
| 4  | 0 | 5 | 3     | \[68, 11, 29, 3, 15, 9, 32, 23] | R: 32 >= 3 → R=5              |
| 5  | 0 | 4 | 3     | \[68, 11, 29, 3, 15, 9, 32, 23] | R: 9 >= 3 → R=4               |
| 6  | 0 | 3 | 3     | \[68, 11, 29, 3, 15, 9, 32, 23] | R: 15 >= 3 → R=3              |
| 7  | 0 | 2 | 3     | \[68, 11, 29, 3, 15, 9, 32, 23] | R: 3 >= 3 → R=2               |
| 8  | 0 | 1 | 3     | \[68, 11, 29, 3, 15, 9, 32, 23] | R: 29 >= 3 → R=1              |
| 9  | 0 | 0 | 3     | \[68, 11, 29, 3, 15, 9, 32, 23] | R: 11 >= 3 → R=0              |
| 10 | 0 | 0 | 3     | \[68, 11, 29, 3, 15, 9, 32, 23] | L < R ❌ → while 종료            |
| 11 | 0 | 0 | 3     | \[3, 11, 29, 68, 15, 9, 32, 23] | pivot(3)과 R(68) 교환 → 피봇 자리 확정 |

#### 결과
`[3, 11, 29, 68, 15, 9, 32, 23]`
이제 피봇(3)은 정렬된 최종 위치에 있으며, 이 기준으로 왼쪽과 오른쪽 부분 배열을 나누어 재귀 정렬 진행.



### 퀵 정렬 수행 과정

예시)

{68, 11, 29, 3, 15, 9, 32, 23}

1) 원소가 8개 이므로 4번째 자리에 있는 원소 3을 첫 번째 피봇으로 정한다.
    -> (68이 L, 23이 R)
2) 퀵 정렬 시작하기
3) 오른쪽 부분 집합에 대해서 퀵 정렬 수행하기
4) 피봇 15의 왼쪽 부분 집합에서 원소 11을 피봇으로 선택하여 퀵 정렬 수행하기
5) 원소 16에 대한 오른쪽 부분 집합에 대해 퀵 정렬을 수행
6) 오른쪽 부분 집합에 대해서 퀵 정렬 수행하기

#### 퀵 정렬의 시간 복잡도
: 합병 정렬에 비해 좋지 못하다
: O(n<sup>2</sup>)

> 그런데 왜 빠른(Quick)정렬 일까?

: 퀵 정렬의 평균 복잡도는 nlogn 이기 때문이다.