# 분할정복

## 분할 정복 알고리즘

### 설계 전략

1. 분할 - 해결할 문제를 **여러 개의 작은 부분**으로 나눔
2. 정복 - 나눈 작은 문제를 **각각 해결**
3. 통합 - (필요하다면) 해결된 **해답을 모음**

### 거듭 제곱 알고리즘 : O(n)

```python
def Power(Base, Exponent):
    if Base == 0 : return 1
    result = 1  # Base^0은 1이므로
    for i in range(Exponent):
        result *= Base
    return result
```

### 분할 정복 기반의 알고리즘 : O(log<sub>2</sub>n)
```python
def Power(Base, Exponent):
    if Exponent == 0 or Base == 0 :
        return 1

    if Exponent % 2 == 0 :
        NewBase = Power(Base, Exponent/2)
        return NewBase * NewBase
    
    else :
        NewBase = Power(Base, (Exponent-1)/2)
        return (NewBase * NewBase) * Base
```

## 퀵 정렬

### 퀵 정렬과 합병 정렬의 비교

||합병정렬|퀵 정렬|
|-|-------|------|
|공통점|주어진 리스트를 두 개로 분할하고, 각각을 정렬|주어진 리스트를 두 개로 분할하고, 각각을 정렬|
|차이점|분할할 때, 단순하게 두 부분으로 나눔|분할할 때, 기준 아이템(Pivot item)을 중심으로, 이보다 **작은 것은 왼편, 큰 것은 오른편**에 위치 시킴|
||각 부분 정렬이 끝난 후, **'합병'이란 후처리 작업이 필요함**|각 부분 정렬이 끝난 후, **후처리 작업이 필요로 하지 않음**|

### 퀵 정렬 알고리즘
```python
def quickSort(a, begin, end):
    if begin < end:
        p = partition(a, begin, end)
        quickSort(a, begin, p-1)
        quickSort(a, p+1, end)
```

### 주어진 리스트에서 피봇을 구하는 알고리즘
```python
def partition (a, begin, end):
    pivot = (begin + end) // 2
    L = begin
    R = end
    while L < R :
        while(a[L] < a[pivot] and L < R):
            L += 1
        while(a[R] >= a[pivot] and L < R):
            R -= 1
        if L < R :
            if L == pivot :
                pivot = R
                a[L], a[R] = a[R], a[L]
    a[pivot], a[R] = a[R], a[pivot]
    return R
```

### 퀵 정렬 수행 과정

예시)

{68, 11, 29, 3, 15, 9, 32, 23}

1) 원소가 8개 이므로 4번째 자리에 있는 원소 3을 첫 번째 피봇으로 정한다.
    -> (68이 L, 23이 R)
2) 퀵 정렬 시작하기
3) 오른쪽 부분 집합에 대해서 퀵 정렬 수행하기
4) 피봇 15의 왼쪽 부분 집합에서 원소 11을 피봇으로 선택하여 퀵 정렬 수행하기
5) 원소 16에 대한 오른쪽 부분 집합에 대해 퀵 정렬을 수행
6) 오른쪽 부분 집합에 대해서 퀵 정렬 수행하기

#### 퀵 정렬의 시간 복잡도
: 합병 정렬에 비해 좋지 못하다
: O(n<sup>2</sup>)

> 그런데 왜 빠른(Quick)정렬 일까?

: 퀵 정렬의 평균 복잡도는 nlogn 이기 때문이다.