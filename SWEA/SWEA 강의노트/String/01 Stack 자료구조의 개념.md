# Stack 자료구조의 개념

## Stack의 특성

### Stack
: 프로그램에서 중요성과 활용도가 매우 높은 자료구조
1. 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
2. 스택에 저장된 자료는 선형구조를 가짐
    - **선형구조란? : 자료 간의 관계가 1대 1의 관계를 가짐**
    - 비선형구조란? : 자료 간의 관계가 1대 N의 관계를 가짐(예: 트리)
3. 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있음
4. 마지막에 삽입한 자료를 가장 먼저 꺼냄
5. **후입선출**(LIFO, Last-In-First-Out)이라고 부름
    - ex) 트랙에 1, 2, 3 순으로 자료를 삽입한 후 꺼내면 역순으로, 즉, 3, 2, 1 순으로 꺼낼 수 있음

## Stack의 구현

### 자료구조
: **자료를 선형으로 저장할 저장소가 필요함**
- C언어에서는 배열을 사용할 수 있음
- 파이썬에서는 리스트를 사용할 수 있음
- 저장소 자체를 스택이라 부르기도 함
- 스택에서 마지막 삽입된 원소의 위치를 top이라 부름

### 연산
1. **삽입** : 저장소에 자료를 저장하고 보통 push라고 부름
2. **삭제** : 저장소에서 자료를 꺼냄. 꺼낸 자료는 삽입한 자료의 역순으로 꺼냄. 보통 pop이라고 부름
3. **isEmpty** : 스택이 공백인지 아닌지를 확인하는 연산
4. **peek** : 스택의 top에 있는 item(원소)을 반환하는 연산

## Stack의 연산

### 스택의 삽입/삭제 연산 과정
- 예시) 빈 스택에 원소 A, B, C를 차례로 삽입 후 한 번 삭제하는 연산 과정

1. 공백스택 이때 마지막 공백스택을 가르키는 top은 자료가 없기 때문에 -1의 값을 가진다.   
2. 이 상태에서 A자료를 삽입하려고 한다.(스택의 연산자 push 사용) - push A   
3. push 연산의 실행으로 스택의 제일 위에 A가 삽입된다.   
    - 이 시점에서 A가 스택의 제일 마지막에 삽입된 자료 이므로 top은 A자료의 위치를 가리키게 된다.     
4. push B를 진행하면 top은 B의 위치를 가리키게 되며   
5. push C를 이어서 진행하면 top은 C의 위치를 가리킨다.
6. pop C 로 맨위의 top의 위치였던 C를 한 번 삭제한다.

### 알고리즘으로 구현

#### push 알고리즘
```python
def push(item):
    s.append(item)
```

#### pop 알고리즘
```python
def pop():
    if len(s) == 0 : # 스택의 크기가 0이라면
        # underflow처리
        return
    else :
        return s.pop(-1) # 아니라면 마지막 값을 반환
```

#### 구현하기
1. 스택을 구현하기
2. 구현한 스택을 이용하여 3개의 데이터를 스택에 저장하고 다시 3번 꺼내서 출력하기

```python
def push(item) :
    s.append(item)
def pop():
    if len(s) == 0 :
        print("Stack is Empty!!") # underflow
        return
    else :
        return s.pop(-1)

s = []
push(1)
push(2)
push(3)
print("pop item =>", pop()) # 3
print("pop item =>", pop()) # 2
print("pop item =>", pop()) # 1
```
### 스택 구현 고려사항

**<u>리스트를 사용**하여 스택을 구현하는 경우</u>
- 장점 : 구현이 용이하다
- **<u>단점</u>** : 리스트의 크기를 변경하는 작업은 내부적으로 큰 overhead 발생 작업으로, 많은 시간이 소요된다.

#### 해결 방법

1. 리스트의 크기가 변동되지 않도록 배열처럼 크기를 미리 정해놓고 사용하는 방법
2. 동적 연결리스트를 이용하여 저장소를 동적으로 할당하여 스택을 구현하는 방법

-> 장점 : 구현이 용이함
-> 단점 : 리스트로 구현하는 것보다 구현이 복잡함